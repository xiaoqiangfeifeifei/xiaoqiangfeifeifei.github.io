<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql基础概念与语法]]></title>
    <url>%2F2017%2F05%2F23%2Fmysql_base%2F</url>
    <content type="text"><![CDATA[由于没有系统学过mysql，之前自己看的相关ppt资料也是囫囵吞枣式的，对视图、游标、事物什么的理解都不是很深刻。特意找了本基础的书（《mysql必知必会》）看了下。 常用命令关键词 登录账户：mysql -u username显示库的信息：show databases操作库之前选择对应的库：use database_name显示库中的表： show tables显示表的列： show columns from table_name 或 describe table_name正则表达式查找： REGEXP （用法同LIKE，只不过关键词右边跟的是正则串） mysql函数 字符串 字符串连接： concat(str…)串左边字符： left(str，len)串右边字符： right(str，len)串长度：length(str)字串位置 ： locate(substr，str)将串转小写：lower(str)将串转大写：upper(str)去全部空格：trim(str)去左边空格：ltrim(str)去右边空格：rtrim(str)返回子串：substirng(str FROM pos FOR len)soundex发音值：soundex(str) 日期 增加时间：Date_add(date，interval expr type)当前日期+时间：now()当前日期：curdate()当前时间：curtime()返回日期部分：Date(expr)返回时间部分：Time(expr)返回年份部分：year(expr)返回月份部分：month(expr)返回天数部分：day(expr)返回分钟部分：month(expr)返回秒数部分：second(expr)返回日期之差(result_type：day)：dateDiff(expr1，expr2)时间格式化：date_format(date,format)返回星期几：dayOfWeek(date) [1=星期日，2=星期一…7=星期六] 全文本查找 需要为被搜索列建立FULLTEXT索引，并且引擎为MYISAM; 建表语句例如：12345678CREATE TABLE test( id int NOT NULL AUTO_INCREMENT, msg text NULL, PRIMARY KEY (id), FULLTEXT(msg))ENGINE=MYISAM; 文本查找语句则为：1select msg from test where Match(msg) against(&quot;xiaoqiang&quot;); 视图 主要用来简化复杂查询语句，创建可重用的 “sql查询接口”，至于更新操作（包括插入，删除）则取决于视图建立条件，如果采用聚合函数、group by等就不允许更新。（更新视图实质上是对原表进行更新，不确定具体字段 自然不会允许更新） 创建视图：1CREATE VIEW `exam_view` AS select * from `exam` where appid = &apos;xxxxxxx&apos;; 存储过程 实质上是sql中的函数，主要用于处理复杂的sql业务（高效，安全）。例如用户商品下单时对库存商品进行一系列处理，检查商品，预定商品，更新库存数目等等 一系列流程就可采用存储过程实现。 创建过程中IN代表函数接收参数，OUT是返回结果，INOUT则复合了IN、OUT的特性。 显示存储过程信息： 12SHOW CREATE PROCEDURE processName;SHOW PROCEDURE STATUS [LIKE processName]; 创建存储过程: 1234CREATE PROCEDURE queryEnameByEid(IN eid_Para INT,OUT ename_result VARCHAR(100)) BEGIN SELECT ename FROM exam WHERE eid=eid_Para INTO ename_result;END; 执行存储过程： 1CALL processName(30,@ename_result); 调用函数结果： 1SELECT @ename_result; 游标 实质上是存储了数据序列的结果集，在mysql中只能用于存储过程中 1234567891011121314151617181920212223242526BEGIN -- 声明局部变量 DECLARE flag INT DEFAULT 0; DECLARE tmp_value VARCHAR(50); -- 声明游标 DECLARE my_cursor CURSOR FOR (SELECT ename FROM exam); -- 建表 CREATE TABLE IF NOT EXISTS test_cursor(id int AUTO_INCREMENT,ename VARCHAR(50),PRIMARY KEY(id)); -- 开启游标 OPEN my_cursor; -- 循环开始 REPEAT -- 将游标获取的值放局部变量里 FETCH my_cursor INTO tmp_value; -- 更改flag值 SET flag=flag+1; -- 插入语句 INSERT INTO test_cursor(ename) VALUES(tmp_value); -- 游标到10时结束循环 UNTIL flag=10 END REPEAT; -- 打印表数据 SELECT * FROM test_cursor; -- 关闭游标 CLOSE my_cursor; END 触发器 将事件与sql执行状况绑定,可使用NEW、OLD虚拟表访问具体操作的字段值 12CREATE TRIGGER delete_question_msg AFTER DELETE ON questionFOR EACH ROW SELECT &apos;delete question finished!&apos; INTO @msg; 12DELETE FROM question WHERE qid=528;SELECT @msg;]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基础符号概念]]></title>
    <url>%2F2017%2F05%2F17%2Fregx_base%2F</url>
    <content type="text"><![CDATA[在项目中解析文件部分使用java Pattern与Matcher类，自然少不了正则啦，在此将正则基础符号概念部分总结一下，比较精简… 句点符号. 任意单个字符 例：a.b 匹配三位长度字符串，中间任意字符；如a b，a1b，a-b等 方括号 圆括号[] 单字符长度范围， () 分组（不限长度） 例：a[123]b 匹配三位长度字符串，中间指定字符；如a1b,a2b,a3b，()用法同理 或符号| 或运算 例：(a|b|cc) 匹配a或b或cc，此处不可使用 [] 星号* 匹配左边字符0次或多次 例：a*[b] 匹配最后一位字符是b,前面字符全为a的字串或单个b字符，如ab，aaab，b 加号+ 匹配左边字符1次或多次 例: a+[b] 匹配第二位是b字符，b字符前面一个或多个a字符的字符串，如aab，ab,aaab 问号\? 匹配左边字符0次或一次（有或无此字符-&gt;有此字符也满足条件） 例：a?[ab] 匹配左边有a字符或无a字符，第二位为a或b的字符串，如a，ab，b 花括号{n} | {m-n} 匹配左边字符恰好n次 或 m-n 次（连续性） 例：a{3}b只匹配字符串aaab 否符号^ 非运算 例：[^a]b匹配第一个字符不是a，第二个字符是b的字符串 常用正则表达式符号\s 等价于 [\t\n\r\f] 即tab制表符、换行符、回车符、换页符，其一，也就是空白字符 \d等价于 [0-9] 也就是数字字符 \w等价于 [A-Z0-9] 也就是字符，字母字符无论大小写都匹配哦 \S \D \W 即上面三种符号定义的“非”逻辑]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>regx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用excel导出demo]]></title>
    <url>%2F2017%2F05%2F03%2Fexcel_export_byReflect%2F</url>
    <content type="text"><![CDATA[通用excel导出demo（利用反射）最近项目后台管理系统好多地方都要用到excel导出。考虑到一次次修改原代码太无聊，各方面拼拼凑凑写出个通用类，传几个参数设定下表头就ok了。对反射的概念和相关api了解又加深了点…代码记录如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import org.apache.poi.hssf.usermodel.*;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;/** * Created by liqiang on 2017/5/9 0009. */public class PoiTool &#123; /** * * @param list 数据源list * @param beanClass list中Object的Class对象 * @param map 表头名与对应字段集合（需预定义，例&#123;&lt;用户名,username&gt;&lt;密码，password&gt;&#125;） * @param response 响应对象 * @throws IllegalAccessException * @throws InstantiationException * @throws InvocationTargetException */ public static void exportExcel(List list, Class beanClass, LinkedHashMap&lt;String, String&gt; map, HttpServletResponse response) throws IllegalAccessException, InstantiationException, InvocationTargetException &#123; int j = 0; String valueStr = &quot;&quot;; HSSFWorkbook wb = new HSSFWorkbook(); HSSFSheet sheet = wb.createSheet(&quot;sheet1&quot;); HSSFCellStyle style = wb.createCellStyle();//样式 style.setAlignment(HSSFCellStyle.ALIGN_CENTER); HSSFRow row = sheet.createRow(0);//第一行 for (Map.Entry&lt;String, String&gt; m : map.entrySet()) &#123;//导入excel表头 HSSFCell cell = row.createCell(j); cell.setCellValue(m.getKey()); cell.setCellStyle(style); sheet.autoSizeColumn(j); valueStr += m.getValue() + &quot;|&quot;;//filed字符串 j++; &#125; valueStr = valueStr.substring(0, valueStr.length() - 1); System.out.println(valueStr); String[] valueArray = valueStr.split(&quot;\\|&quot;);//filed数组 //通过反射获取对应beanClass中的字段 //并将其转为get方法置入集合中 Field field[] = beanClass.getDeclaredFields(); List&lt;Method&gt; methodlist = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; field.length; i++) &#123; String fieldName = field[i].getName(); StringBuffer methodName = new StringBuffer(&quot;get&quot;); methodName.append(fieldName.substring(0, 1).toUpperCase()); methodName.append(fieldName.substring(1)); Method getMethod = null; try &#123; getMethod = beanClass.getMethod(methodName.toString()); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; methodlist.add(getMethod); &#125; //遍历list，并插入数据 for (int i = 0; i &lt; list.size(); i++) &#123; row = sheet.createRow(i + 1);//创建行，从第二行开始 for (int k = 0; k &lt; valueArray.length; k++) &#123;//遍历column Method getMethod = getCurrentMethod(valueArray[k], methodlist);//获取colunm对应的get方法 if (getMethod.getReturnType().toString().indexOf(&quot;int&quot;) &gt;= 0) &#123; row.createCell(k).setCellValue((int) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; else if (getMethod.getReturnType().toString().indexOf(&quot;String&quot;) &gt;= 0) &#123; row.createCell(k).setCellValue((String) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; else if (getMethod.getReturnType().toString().indexOf(&quot;double&quot;) &gt;= 0) &#123; row.createCell(k).setCellValue((double) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; else if (getMethod.getReturnType().toString().indexOf(&quot;float&quot;) &gt;= 0) &#123; row.createCell(k).setCellValue((float) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; &#125; sheet.autoSizeColumn(i); &#125; response.reset(); response.setContentType(&quot;application/vnd.ms-excel;charset=gb2312&quot;); response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=excel.xls&quot;); try &#123; OutputStream outputStream = response.getOutputStream(); wb.write(outputStream); wb.close(); outputStream.flush(); outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //获取当前column的get方法 public static Method getCurrentMethod(String valueArray, List&lt;Method&gt; methodlist) &#123; if (valueArray != null &amp;&amp; methodlist.size() &gt; 0) &#123; for (int i = 0; i &lt; methodlist.size(); i++) &#123; if (methodName(methodlist.get(i).getName()).equals(valueArray)) &#123; return methodlist.get(i); &#125; &#125; &#125; return null; &#125; //处理methodName public static String methodName(String str) &#123; if (str != null) &#123; str = str.substring(3).substring(0, 1).toLowerCase() + str.substring(3).substring(1); return str; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众平台普通红包发放]]></title>
    <url>%2F2017%2F04%2F25%2Fweixin_web_OrdinaryRedPacket%2F</url>
    <content type="text"><![CDATA[业务需求：在后台管理系统为微信用户发放红包，弄了好几天总算搞定了，需要注意的是获取签名部分，流程大体如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210//红包业务方法public int sendRedpack(HttpServletRequest request,UserAverage userAverage) throws Exception &#123; WechatInfo wechat = getWechatInfo(request); WechatInfo wechatInfo = wechatInfoService.queryWechatinfo(wechat.getAppid()); String sendName =wechatInfo.getWxname(); //微信证书路径 String certPath =this.getClass().getResource(&quot;/&quot;).getPath()+&quot;xxxxx/apiclient_cert.p12&quot;; certPath = URLDecoder.decode(certPath,&quot;UTF-8&quot;);//证书路径解码 logger.info(&quot;证书路径:&quot;+certPath); //商户id String wxappid = wechatInfo.getAppid(); // 微信支付分配的商户号 String partner = wechatInfo.getPartnerid(); //API密钥 String paternerKey =wechatInfo.getPartnerkey(); /** * 发送普通红包 */ boolean isSend = sendredpack(wechatInfo,request, &quot;100&quot;, &quot;1&quot;, &quot;恭喜您获得竞赛奖金！&quot;, &quot;竞赛答题活动&quot;, &quot;竞赛奖金&quot;, userAverage.getOpenid(), partner, wxappid, sendName, paternerKey, certPath); if(!isSend)&#123; return 0; &#125; return 1;&#125;// 主封装方法// * @param request 获取IP// * @param total_amount 付款现金(单位分)// * @param total_num 红包发放总人数// * @param wishing 红包祝福语// * @param act_name 活动名称// * @param remark 备注// * @param reOpenid 用户openid// * @param partner 商户号// * @param wxappid 公众账号appid// * @param sendName 商户名称// * @param paternerKey 商户签名key// * @param certPath 证书路径// * @return// */ public static boolean sendredpack(WechatInfo wechatInfo,HttpServletRequest request,String total_amount,String total_num,String wishing,String act_name,String remark,String reOpenid,String partner,String wxappid,String sendName,String paternerKey,String certPath) throws Exception&#123; // 商户订单号 String mchBillno = RedPackUtil.createBillNo(wechatInfo); String ip =&quot;xxx.xx.xxx.xx&quot;;//服务器IP Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(); // 随机字符串 params.put(&quot;nonce_str&quot;, RedPackUtil.createNonce_str()); // 商户订单号 params.put(&quot;mch_billno&quot;, mchBillno); // 商户号 params.put(&quot;mch_id&quot;, partner); // 公众账号ID params.put(&quot;wxappid&quot;, wxappid); // 商户名称 params.put(&quot;send_name&quot;, sendName); // 用户OPENID params.put(&quot;re_openid&quot;, reOpenid); // 付款现金(单位分) params.put(&quot;total_amount&quot;, total_amount); // 红包发放总人数 params.put(&quot;total_num&quot;, total_num); // 红包祝福语 params.put(&quot;wishing&quot;, wishing); // 终端IP params.put(&quot;client_ip&quot;, ip); // 活动名称 params.put(&quot;act_name&quot;, act_name); // 备注 params.put(&quot;remark&quot;, remark); //创建签名 String sign = RedPackUtil.redSignal(params, paternerKey); logger.info(&quot;md5签名：&quot;+sign); params.put(&quot;sign&quot;, sign); String xmlResult = RedPackUtil.sendRedPack(params, certPath, partner);//执行发送红包 logger.info(&quot;发送红包返回结果：&quot;+xmlResult.toString()); Map&lt;String, String&gt; result = XMLUtil.xml2Map(xmlResult); logger.info(&quot;红包参数：&quot;+result.toString()); //此字段是通信标识，非交易标识，交易是否成功需要查看result_code来判断 String return_code = result.get(&quot;return_code&quot;); //业务结果 String result_code = result.get(&quot;result_code&quot;); if (StringUtils.isNotBlank(return_code) &amp;&amp; &quot;SUCCESS&quot;.equals(return_code)) &#123; logger.info(&quot;通信成功return_code：&quot;+return_code); if (StringUtils.isNotBlank(result_code) &amp;&amp; &quot;SUCCESS&quot;.equals(result_code)) &#123; logger.info(&quot;发送成功result_code：&quot;+result_code); return true; &#125;else&#123; logger.info(&quot;发送失败result_code：&quot;+result_code); &#125; &#125;else&#123; logger.info(&quot;通信失败return_code：&quot;+return_code); &#125; return false; &#125; /** * 生成商户订单号 * @param mch_id 商户号 * @param userId 该用户的userID * @return */public static String createBillNo(WechatInfo wechatInfo)&#123; //组成： mch_id+yyyymmdd+10位一天内不能重复的数字 //10位一天内不能重复的数字实现方法如下: //因为每个用户绑定了userId,他们的userId不同,加上随机生成的(10-length(userId))可保证这10位数字不一样 Date dt=new Date(); SimpleDateFormat df = new SimpleDateFormat(&quot;yyyymmdd&quot;); String nowTime= df.format(dt); int length = 10 ; return wechatInfo.getPartnerid() + nowTime + getRandomNum(length);&#125;/** * 生成红包参数随机数nonce_str * @return */public static String createNonce_str()&#123; return System.currentTimeMillis()/1000+getRandomNum(5);&#125;/** * 生成特定位数的随机数字 * @param length * @return */public static String getRandomNum(int length) &#123; String val = &quot;&quot;; Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; val += String.valueOf(random.nextInt(10)); &#125; return val;&#125;/*** @Title: redSignal * @Description: 发送红包签名生成* @param @param params* @param @return 设定文件 * @return String 返回类型 * @throws*/public static String redSignal(Map&lt;String, String&gt; params,String paternerKey) &#123;SortedMap&lt;String, String&gt; packageParams = new TreeMap&lt;String, String&gt;();for (Map.Entry&lt;String, String&gt; m : params.entrySet()) &#123;packageParams.put(m.getKey(), m.getValue().toString());&#125;StringBuffer sb = new StringBuffer();Set&lt;?&gt; es = packageParams.entrySet();Iterator&lt;?&gt; it = es.iterator();while (it.hasNext()) &#123;Map.Entry entry = (Map.Entry) it.next();String k = (String) entry.getKey();String v = (String) entry.getValue();if (!StringUtils.isEmpty(v) &amp;&amp; !&quot;sign&quot;.equals(k) &amp;&amp; !&quot;key&quot;.equals(k)) &#123;sb.append(k + &quot;=&quot; + v + &quot;&amp;&quot;);&#125;&#125;sb.append(&quot;key=&quot; + paternerKey);System.out.println(&quot;未加密签名：&quot;+sb.toString());String sign = MD5Util.MD5Encode(sb.toString(),&quot;UTF-8&quot;).toUpperCase();return sign;&#125;private static String sendRedPackUrl = &quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack&quot;;/** * 发送红包 * @param params 请求参数 * @param certPath 证书文件目录 * @param partner 证书密码 * @return &#123;String&#125; * @throws Exception */public static String sendRedPack(Map&lt;String, String&gt; params, String certPath, String partner) throws Exception &#123; return doSend(sendRedPackUrl, XMLUtil.map2Xmlstring(params), certPath, partner);&#125;public static String doSend(String url, String data , String certPath , String partner) throws Exception &#123; KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;); FileInputStream instream = new FileInputStream(new File(certPath));//P12文件目录 try &#123; keyStore.load(instream, partner.toCharArray());//这里写密码..默认是你的MCHID &#125; finally &#123; instream.close(); &#125; SSLContext sslcontext = SSLContexts.custom() .loadKeyMaterial(keyStore, partner.toCharArray())//这里也是写密码的 .build(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] &#123; &quot;TLSv1&quot; &#125;, null, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER); CloseableHttpClient httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build(); try &#123; HttpPost httpost = new HttpPost(url); // 设置响应头信息 httpost.addHeader(&quot;Connection&quot;, &quot;keep-alive&quot;); httpost.addHeader(&quot;Accept&quot;, &quot;*/*&quot;); httpost.addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;); httpost.addHeader(&quot;Host&quot;, &quot;api.mch.weixin.qq.com&quot;); httpost.addHeader(&quot;X-Requested-With&quot;, &quot;XMLHttpRequest&quot;); httpost.addHeader(&quot;Cache-Control&quot;, &quot;max-age=0&quot;); httpost.addHeader(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) &quot;); httpost.setEntity(new StringEntity(data, &quot;UTF-8&quot;)); CloseableHttpResponse response = httpclient.execute(httpost); try &#123; HttpEntity entity = response.getEntity(); String jsonStr = toStringInfo(response.getEntity(),&quot;UTF-8&quot;); EntityUtils.consume(entity); return jsonStr; &#125; finally &#123; response.close(); &#125; &#125; finally &#123; httpclient.close(); &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序支付接口二次签名]]></title>
    <url>%2F2017%2F04%2F12%2Fweixin_miniProgram_sign%2F</url>
    <content type="text"><![CDATA[今天小程序的支付接口遇到签名错误问题。折腾半天…原因是：小程序支付的签名需要进行2次！！！不是成功获取订单后微信服务器回调的xml中的那个sign。 接口返回下列参数供小程序调用1234paySign //签名 prePay.getMiniPackage(prepayid));timeStamp //时间戳 prePay.getTimeStamp());nonceStr//随机签名 prePay.getNonce_str()); package//预支付订单，格式为prepay_id=*; 其中主要参数 paySign，是二次签名。具体签名参数 是采用 调用微信接口获取到预支付订单prepayid后服务器返回的参数（包括小程序需要调用的nonceStr,prepay_id）， 主要用下列参数生成paySign，语法如下：1appId=【appid】&amp;nonceStr=【随机字符串】&amp;package=prepay_id=【返回的prepay_id】&amp;signType=MD5&amp;timeStamp=【时间戳】&amp;key=【支付秘钥】 二次签名代码如下：12345678910111213141516171819public String getMiniPackage(String prepay_id) &#123; TreeMap&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;(); String timeStamp=OrderUtil.GetTimestamp(); setTimeStamp(timeStamp); treeMap.put(&quot;appId&quot;, this.appid); treeMap.put(&quot;nonceStr&quot;, getNonce_str()); treeMap.put(&quot;package&quot;, &quot;prepay_id=&quot;+prepay_id); treeMap.put(&quot;signType&quot;, &quot;MD5&quot;); treeMap.put(&quot;timeStamp&quot;,timeStamp); StringBuilder sb = new StringBuilder(); for (String key : treeMap.keySet()) &#123; sb.append(key).append(&quot;=&quot;).append(treeMap.get(key)).append(&quot;&amp;&quot;); &#125; sb.append(&quot;key=&quot; + partnerKey); System.out.println(&quot;小程序二次签名：&quot;+sb.toString()); sign = MD5Util.MD5Encode(sb.toString(), &quot;utf-8&quot;).toUpperCase(); return sign;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决url传中文参数乱码]]></title>
    <url>%2F2017%2F03%2F23%2FURL_ChineseParameter_MessyCode%2F</url>
    <content type="text"><![CDATA[解决url传中文参数乱码首先在前台js内将相应的中文参数（qsInfo）编码两次，相应代码如下。可用encodeURIComponent直接对中文参数进行编码，直接使用encodeURIComponent对url进行编码会使 / 字符转为16进制字符，这时你会发现页面没有定向到url的地址…1234var url=encodeURI(encodeURI(&apos;$&#123;ctx&#125;/backstage/getPraxisQuestionList?qsInfo=&apos;+qsInfo));or...var url=&apos;$&#123;ctx&#125;/backstage?qsInfo=&apos;+encodeURIComponent(encodeURIComponent(qsInfo));//var url=encodeURIComponent(encodeURIComponent(&apos;$&#123;ctx&#125;/backstage?qsInfo=&apos;+qsInfo));//url不跳转，/被编码了... 接着在java后台对相应字符进行解码就ok啦，代码如下 1String qsInfo = URLDecoder.decode(question.getQsInfo(),&quot;UTF-8&quot;);//字符解码,此处我的参数是直接封装在bean里的。 具体流程就是：前台编码2次，后台解码1次…]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
</search>
