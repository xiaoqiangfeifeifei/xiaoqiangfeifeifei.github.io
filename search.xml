<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis API 入门]]></title>
    <url>%2F2018%2F01%2F26%2Fredis%2Fredis_base%2F</url>
    <content type="text"><![CDATA[基本 windows 连接redis: redis-cli.exe -h 127.0.0.1 -p 6379 查看所有的key: keys * 删除所有key value : flushall 查看当前数据库键的数量： dbsize 切换数据库 ： select [index] 获取键值的数据类型：type key 字符串(string) 插入键： set key value 获取值： get key 多重插入键：mset key value 多重获取值： mget key 判断键是否存在：exists key 删除键：del key (删除不支持通配符，不过支持多键参数：redis-cli DEL ‘redis-cli KEYS “user:*”‘) 递增数字: incr key 增加指定整数： incrby key increment 减少指定整数： decrby key increment 增加指定浮点数： incrbyfloat key increment 追加value: append key value 获取字符串长度： strlen key 散列(hash) 插入键值： hset key field value 获取值： hget key field 获取全部键值： hgetall key 多重插入键：hmset key field1 value1 field2 value2* 多重获取值： hmget key field1 field1 判断键是否存在：hexists key field 插入键值（原子，键值存在则不插入） ： hsetnx key field 增加指定整数： hincrby key field increment 删除键值： hdel key field 只获取字段名：hkeys key 只获取字段值：hvals key 获取字段数量： hlen key 列表(list) 向列表左边添加元素(创建元素)： lpush key value 向列表右边添加元素(创建元素)： rpush key value 从左边弹出一个元素：lpop key 从右边弹出一个元素：rpop key 获取列表中元素数量：llen key 获取列表中片段： lrange key 0 2 删除元素： lrem key count value 当count&gt;0，从左边删除count个value值 当count&lt;0，从右边删除|count|个value值 当count=0，整个列表中删除value值 根据index获取元素：lindex key index 指定index位置的的元素：lset key index value 修剪列表： ltrim key start end 插入元素：linsert key before|after pivot value 将元素从一个列表转向另一个列表：rpoplpush source destination 集合(set) 添加元素：sadd key value[…] 删除元素：srem key value[…] 获取全部集合元素： smembers key 判断元素是否存在： sismember key value 获取集合元素个数：scard key 随机弹出元素： spop 随机获取：srandmember key count 当count&gt;0，从集合获取count个不重复值，count&gt;集合元素数目，获取全部 当count&lt;0，从集合获取|count|个值，元素有可能重复 差：sdiff setA setB[…] 交集 : sinner setA setB[…] 并集 : sunion setA setB[…] 差：sdiffstore destination setA setB[…] 交集：sinner destination setA setB[…] 并集：sunion destination setA setB[…] 有序集合（sorted set） 有序集合和列表相似，不过二者使用场景还是有很多不同的。1.列表是通过链表实现，获取靠近两端数据极快，比较适合“新鲜事”、“日志”这样比较少访问中间元素的应用。2.有序集合是使用散列表和跳跃表来实现，即时读取中间位置元素，速度也很快（时间复杂度O(log(N))）。3.列表不能简单地调整元素位置，有序集合可以（更改分数）。4.有序集合比列表更耗费内存。 添加元素：zadd key score member […] 获得元素分数：zscore key member 获取集合中片段（分数由小到大排序）： zrange key start stop[withscores] 获取集合中片段（分数由大到小排序）： zrevrange key start stop[withscores] 根据分数范围获取列表中片段（分数由小到大排序）：zrangebyscore key min max [withscores ] [limit offset count] 根据分数范围获取集合中片段（分数由大到小排序）：zrevrangebyscore key max min [withscores ] [limit offset count] +inf -inf 代表正负无穷 1 (5 代表数学上的[1 5) 改变元素分数：zincrby key increment member 获取集合中元素数量: zcard key 获取指定分数范围内元素数目： zcount key min max 删除元素： zrem key member[…] 按照排名rank删除元素： zremrangebyrank key start stop 按照分数删除元素： zremrangebyrank key min max 获取元素排名(正序，分数最小的排名0)： zrank key member 获取元素排名（倒序，分数最大的排名0）：zrevrank key member 计算有序集合的交集（并集同理）：zinterstore destination numkeys key[…] [aggregate :sum|min|max]其中numkeys是交集集合元素数目，aggregate选项是交集集合score的具体来源方式，例如aggregate=sum，此时交集集合当前元素的score就是所有被交集的元素score的和。 附上jedis相关api测试代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198/** * test redis api */public class testRedisApi &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis("localhost"); //testString(jedis); //testHash(jedis); //testList(jedis); //testSet(jedis); testZset(jedis); &#125; /** * 测试String类型 * @param jedis */ private static void testString (Jedis jedis) &#123; if (!jedis.exists("color:0")) &#123; print("插入 string data...",true); // 新增key value jedis.set("color:0","red"); &#125; print("测试String类型..."); String key = "color:0"; // 判断key是否存在 print("判断key是否存在" + jedis.exists(key)); // 根据key获取value print("初始值 = " + jedis.get(key)); // 根据key追加value jedis.append(key,"|blue"); print("追加blue后的值: "+ jedis.get(key)); // 获取string长度 print("获取string长度: "+ jedis.strlen(key)); // 删除 jedis.del(key); print("删除key后的值: "+ jedis.get(key)); // 递增数字键 print("test递增数字键: "+ jedis.incr("id")); print("test递增数字键: "+ jedis.incr("id")); jedis.set("color:0","red"); &#125; /** * 测试Hash类型 * @param jedis */ private static void testHash (Jedis jedis) &#123; if (jedis.hlen("car0") == 0) &#123; print("插入 hash data...",true); // 新增hash数据 Map&lt;String,String&gt; hashMap = new HashMap&lt;&gt;(); hashMap.put("brand","BMW"); hashMap.put("color","black"); hashMap.put("price","888888"); jedis.hmset("car0",hashMap); &#125; print("测试Hash类型..."); String key = "car0"; // 根据key获取field value print("获取field值：" + jedis.hget(key,"brand")); // 获取全部field value (Map) print("获取全部field值：" + jedis.hgetAll(key)); // 判断filed是否存在 print("判断filed是否存在：" + jedis.hexists(key,"brand")); // 获取全部field print("获取全部field：" + jedis.hkeys(key)); // 获取全部value print("获取全部value: " + jedis.hvals(key)); // 删除指定field print("删除指定field: " + jedis.hdel(key,"color","price","brand")); // 获取field数量 print("获取field数量:" +jedis.hlen(key)); &#125; /** * 测试List类型 * @param jedis */ private static void testList (Jedis jedis) &#123; if (jedis.llen("girls") == 0) &#123; print("插入 list data...",true); // 新增list数据 jedis.lpush("girls","yuyu"); jedis.rpush("girls","jingjing"); jedis.rpush("girls","qiqi"); &#125; print("测试List类型..."); String key = "girls"; //获取list中片段(-1代表最后一个) print(jedis.lrange(key,0,-1).toString()); // 从左边pop一个元素（右边rpop） print(jedis.lpop(key)); // 获取list中元素数量 print("list中元素数量" +jedis.llen(key)); // 根据index获取元素 print("根据index获取元素:" + jedis.lindex(key,0)); // 根据index设置元素(index必须是在当前数组域中，否则报ERR index out of range) print("根据index设置元素:" + jedis.lset(key,0,"huhu")); // 删除元素 // 当count&gt;0，从左边删除count个value值 // 当count&lt;0，从右边删除|count|个value值 // 当count=0，整个列表中删除value值 print("删除元素:" + jedis.lrem(key,0,"huhu")); // 插入元素到指定位置 print("插入元素到指定位置:"+ jedis.linsert(key, BinaryClient.LIST_POSITION.AFTER,"yuyu","hxhx")); // 将元素从一个列表转向另一个列表 print("元素从一个列表转向另一个列表:" + jedis.rpoplpush(key,"test")); // 修剪list列表 print("修剪list列表:" + jedis.ltrim("test",jedis.llen("test"),jedis.llen("test"))); &#125; /** * 测试Set类型 * @param jedis */ private static void testSet (Jedis jedis) &#123; if (jedis.scard("languages") == 0) &#123; print("插入 Set data...",true); // 新增set数据 jedis.sadd("languages","java","java","javascript","python","golang"); &#125; print("测试Set类型..."); String key = "languages"; // 获取全部集合元素 (Set 无序) print("获取全部集合元素：" + jedis.smembers(key)); // 判断元素是否存在 print("判断元素是否存在：" + jedis.sismember(key,"java")); // 随机pop元素 print("随机pop元素:" + jedis.spop(key)); // 随机获取 // 当count&gt;0，从集合获取count个不重复值，count&gt;集合元素数目，获取全部 // 当count&lt;0，从集合获取|count|个值，元素有可能重复 print("随机获取元素:" + jedis.srandmember(key,1)); // 移除集合指定成员 print("移除集合指定成员:" + jedis.srem(key,"java","javascript")); jedis.sadd("set1","1","2","3"); jedis.sadd("set2","1","4","5"); // 差集 print("差集：" + jedis.sdiff("set1","set2")); // 交集 print("交集：" + jedis.sinter("set1","set2")); // 并集 print("并集："+ jedis.sunion("set1","set2")); &#125; /** * 测试Zset类型 * @param jedis */ private static void testZset (Jedis jedis) &#123; if (jedis.zcard("phones") == 0) &#123; print("插入 Zset data...",true); // 新增zset数据 Map&lt;String,Double&gt; zMap = new HashMap&lt;&gt;(); zMap.put("xiaomi",1.0); zMap.put("huawei",1.0); zMap.put("oneplus",2.0); zMap.put("apple",3.0); jedis.zadd("phones",zMap); &#125; print("测试Zset类型..."); String key = "phones"; // 根据index获取集合片段(socre由小到大排序，zrevrange是相反的) print("根据index获取集合片段："+ jedis.zrange(key,0,-1)); // 获取元素score print("获取元素score:" + jedis.zscore(key,"apple")); // 根据score范围获取集合片段(四个参数分别为：MAX socre，MIN score, offset[偏移量] ,count[数目]) print("根据score获取集合片段：" + jedis.zrevrangeByScore(key,4,0,1,1)); // 获取指定score范围内元素数目 print("获取指定score范围元素数目：" + jedis.zcount(key,0,2)); // 改变元素score print("改变元素socre:" + jedis.zincrby(key,4,"huawei")); // 获取元素排名index（正序） print("获取元素排名：" + jedis.zrank(key,"huawei")); &#125; /** * 打印消息（不切行） * @param str */ private static void print (String str) &#123; print(str,false); &#125; /** * 打印消息（切行） * @param str */ private static void print (String str,boolean isNextLine) &#123; if (isNextLine) &#123; System.out.println(str+"\n"); return; &#125; System.out.println(str); &#125;&#125;]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码]]></title>
    <url>%2F2018%2F01%2F09%2FresourceCode%2FJava_ArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList 本质是数组 初始容量DEFAULT_CAPACITY = 10 get ， set操作比较有效率，是直接根据索引来操作 add，remove操作涉及到index时，需要对数组拷贝，消耗大 代码块 成员变量： 123456789101112131415161718192021222324/** * 默认数组容量 */private static final int DEFAULT_CAPACITY = 10;/** * 有参构造器初始容纳数组 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/** * 无参构造器初始容纳数组 */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * 存放数据的缓冲区 */transient Object[] elementData; // non-private to simplify nested class access/** * 容纳数据数 */private int size; 构造器： 三种构造方式：无参数，int参数，Collection参数 1234567891011121314151617181920212223242526272829303132333435/** * 无参构造器，默认以初始容量DEFAULT_CAPACITY = 10 构造 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 参数为int的构造器 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //initialCapacity参数大于0，直接构建对象 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123;//initialCapacity参数等于0，用EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125; &#125; /** * 参数为Collection的构造器 */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray();//将Collection参数转数组 if ((size = elementData.length) != 0) &#123;//Collection参数中存在数据时（非空Collection） // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 辅助方法： 123456789101112131415161718192021222324252627282930313233343536373839 /** * 增加Array容量 */private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0)// 要求的容量大于此时数组容量，触发grow（） grow(minCapacity); &#125; /** * 最大容量 * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length;//当前数组容量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//新数组容量（右移一位代表除2^1位，新容量是旧容量的1.5倍） if (newCapacity - minCapacity &lt; 0)//新容量仍然不满足要求的容量 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0)//新容量大于最大容量 newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow ？？？？为什么会出现小于0情况 throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? //要求的容量大于最大容量时用Integer.MAX_VALUE尝试 ，否则用MAX_ARRAY_SIZE（也就是不可以按1.5倍来扩容了，数组实在太大） Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 常用API : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153 /** * 正序返回index */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 倒序返回index */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; /** * 根据index获取数据元素，对数组直接操作，比较高效 */ public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; /** * 根据index放入数据元素，对数组直接操作，比较高效 */ public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; /** * 不要求index次序的添加，对数组直接操作，也比较高效 */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * 要求index次序的添加，需要拷贝数组，比较耗费资源 */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; /** * 移除指定位置元素，需要拷贝数组，比较耗费资源 */ public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index);//被移除的元素 int numMoved = size - index - 1;//index后的元素数目 if (numMoved &gt; 0)//index后存在元素（也就是被移除的这个元素不是最后一个） System.arraycopy(elementData, index+1, elementData, index, numMoved);//index后存在元素（也就是被移除的这个元素不是最后一个）将index后的元素复制过来 elementData[--size] = null; // （最后一个数组位置将其变成null,因为复制完后面的元素均前移一步，最后位置此时无值）clear to let GC do its work return oldValue; &#125; /** * 移除指定的元素，需要拷贝数组，比较耗费资源 */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; /** * 与public remove(int index)方法差不多,只不过没有返回值 */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /** * 清除所有元素 */ public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; /** * 将Collection添加进ArrayList中，需要拷贝数组，比较耗费资源 */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * 根据index来添加Collection，需要拷贝数组，比较耗费资源 */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 三种循环效率 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class testArrayList &#123; public static void main(String[] args) &#123; List list = new ArrayList(); for (int i = 0; i &lt;10000 ; i++) &#123; list.add(i); &#125; testArrayList.iterateByForEach(list); testArrayList.iterateByiterator(list); testArrayList.iterateByRandomAccess(list); &#125; private static void iterateByRandomAccess (List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i = 0; i &lt;list.size() ; i++) &#123; list.get(i); &#125; endTime = System.currentTimeMillis(); System.out.println("iterateByRandomAccess Time is :" + (endTime - startTime)); &#125; private static void iterateByForEach (List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (Object obj : list) &#123; &#125; endTime = System.currentTimeMillis(); System.out.println("iterateByForEach Time is :" + (endTime - startTime)); &#125; private static void iterateByiterator (List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (Iterator iterator = list.iterator(); iterator.hasNext();) &#123; iterator.next(); &#125; endTime = System.currentTimeMillis(); System.out.println("iterateByiterator Time is :" + (endTime - startTime)); &#125;&#125; 随机访问 iterateByRandomAccess 最快 iforEach循环 中等速度 迭代器 iterateByiterator 最慢]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2017%2F12%2F19%2FdesignPattern%2F7_adapter_pattern%2F</url>
    <content type="text"><![CDATA[适配器模式 概念有时候在程序中需要对接口进行适配，也就是已有的接口（实现类的方法）在某个业务上不能满足我们的需要，需要我们改写下已有的接口，使之符合我们的需要。但是已有的接口不能动（因为可能项目中其他地方已经在用这个接口），这时候就需要适配器来解决这个问题了。 定义： 适配器模式(Adapter Pattern)：将一个类的接口转换成客户期望的另一个接口，让原本不兼容的接口可以合作无间。 实例举个例子吧，中国电流标准电压是220v，笔记本电脑需要的电压是20v，这时就需要个电源适配器来让笔记本正常工作了。 123456789101112131415161718192021222324252627282930313233343536//电流接口public interface Electric &#123; public void display();&#125;//国标电流public class GBElectric implements Electric &#123; @Override public void display() &#123; System.out.println("220V电流"); &#125;&#125;//笔记本电脑public class Computer &#123; Electric electric; public Computer (Electric electric) &#123; this.electric = electric; &#125; public void work () &#123; electric.display(); &#125;&#125;//客户端public class Client &#123; public static void main(String[] args) &#123; Electric elec ; elec = new GBElectric(); Computer computer = new Computer(elec); computer.work(); &#125;&#125;运行结果：220V电流 运行结果很显然不对，这时就需要我们用适配器来更改下了。1234567//适配器public class ElectricAdapter extends GBElectric &#123; @Override public void display() &#123; System.out.println("20V电流"); &#125;&#125; 客户端代码变为：12345678910public class Client &#123; public static void main(String[] args) &#123; Electric elec ; elec = new ElectricAdapter(); Computer computer = new Computer(elec); computer.work(); &#125;&#125;运行结果：20V电流 可以看到我们只是扩展了原本的GBElectric类与改了下客户端代码，原本接口（GBElectric ）与后端（Computer）代码不变，完全符合开闭原则。 总结缺点 java不支持多继承，一次只能适配一个接口 适用场景 现有接口不满足业务需求时，需要更改]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2017%2F12%2F13%2FdesignPattern%2F6_builder_pattern%2F</url>
    <content type="text"><![CDATA[建造者模式 概念设计系统时有时会需要实现相对复杂对象的构建，建造者模式就是为了解决这个问题的。建造者模式返回的是由多个部件组成的复杂产品，它专注于一个复杂对象的构建。 定义： 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 结构图如下： 实例建造者模式主要由产品类，抽象建造者，具体建造者，指挥者组成，其中指挥者可根据不同需求进行更改。 以常见的成员信息统计为例子,产品类如下： 123456789101112/** * 产品角色 */public class MemberInfo &#123; private String name; private int age; private String sex; private String phone; private String addr; //get set 省略....&#125; 抽象建造者和具体建造者分别如下：12345678910111213141516/** * 建造抽象 */public abstract class MemberInfoBuilder &#123; protected MemberInfo memberInfo = new MemberInfo(); public abstract void buildName (); public abstract void buildAge (); public abstract void buildSex (); public abstract void buildPhone (); public abstract void buildAddr (); public MemberInfo createMemmerInfo()&#123; return this.memberInfo; &#125;&#125; 1234567891011121314151617181920212223242526272829/** * 具体建造者 */public class XiaoHuaMemberInoBuilder extends MemberInfoBuilder&#123; @Override public void buildName() &#123; memberInfo.setName("小花"); &#125; @Override public void buildAge() &#123; memberInfo.setAge(22); &#125; @Override public void buildSex() &#123; memberInfo.setSex("女"); &#125; @Override public void buildPhone() &#123; memberInfo.setPhone("11111111111"); &#125; @Override public void buildAddr() &#123; memberInfo.setAddr("美国洛杉矶"); &#125;&#125; 指挥者代码如下： 123456789101112131415161718192021/** * 指挥者 */public class MemberInfoController &#123; public MemberInfo construct (MemberInfoBuilder builder) &#123; MemberInfo memberInfo; builder.buildName(); builder.buildSex(); builder.buildAge(); builder.buildAddr(); builder.buildPhone(); memberInfo = builder.createMemmerInfo(); return memberInfo; &#125; public static void main(String[] args) &#123; MemberInfoController memberInfoController = new MemberInfoController(); MemberInfo memberInfo = memberInfoController.construct(new XiaoHuaMemberInoBuilder()); System.out.println(memberInfo.getName());//小花 &#125;&#125; 上诉代码关键部分在于抽象建造者里的 protected MemberInfo memberInfo = new MemberInfo() ，将 MemBerInfo对象的访问权限设置为 protected，以便于子类可以在被覆写的抽象方法里直接对其进行操作。 总结指挥者类的功能可以在抽象建造者里面直接实现，这样可以减少类的数目，不过违背了“开闭原则”，以后若要进行建造顺序等更改，必须修改源代码。也可以在抽象建造者里面增加钩子方法，控制具体建造过程。 缺点 使用范围受到限制，适合一系列相似的复杂产品的创建 加大系统复杂度，增加理解难度与运行成本 适用场景 隔离复杂对象的创建与使用 对象属性互相依赖，例如控制属性生成的顺序]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2017%2F12%2F12%2FdesignPattern%2F5_prototype_pattern%2F</url>
    <content type="text"><![CDATA[原型模式 概念在设计系统过程中，有时候可能需要一些相同的或相似的对象，这时可以采用原型模式。 定义： 原型模式(Prototype Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 实例java中的原型模式很简单，也就是Object对象的clone()方法，不过只是浅拷贝，也就是采用clone方法获得的拷贝对象不会将引用类型也拷贝下来，只会拷贝基本类型。需要注意的是：正确拷贝的对象与原来的对象不在一个内存地址上，也就是它们是两个互相独立的对象，互不影响，只是内容看起来一样而已。 下面以文件复制过程来演示下浅拷贝：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * ShallowClone */public class File implements Cloneable&#123; private String name; private String content; private Date date; private List&lt;String&gt; list; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date data) &#123; this.date = data; &#125; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; @Override public File clone () &#123; Object obj = null; try &#123; obj = super.clone(); return (File) obj; &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 客户端代码如下：12345678910111213141516171819202122public class Client &#123; public static void main(String[] args) &#123; File file0 = new File(); file0.setName("记事本0"); file0.setContent("呜呜呜呜呜呜呜呜呜"); file0.setDate(new Date()); ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(3); list.add("1"); list.add("2"); list.add("3"); file0.setList(list); File file1 = file0.clone(); file1.setName("记事本1"); System.out.println(file0 == file1);//false System.out.println(file0.getClass() == file1.getClass()); //true System.out.println(file0.getDate() == file1.getDate());//true System.out.println(file0.getList() == file1.getList());//true &#125;&#125; 输出结果似乎没问题，不过我们可以看到file0.getList() == file1.getList()结果竟然是true。对于引用类型来说，用 ==比较符比较的应该是内存地址。结果为true说明file0与file1都指向同一个对象，file1只是把“指针”给复制过来了。将来如果对file0中的List进行修改，file1中的List也会被改变。这就是所谓的浅拷贝了。 如果要实现深拷贝需要我们自己实现编码，被拷贝的对象必须实现Serializable接口。下面随便建立一个带List成员的类演示下实现深拷贝： 1234567891011121314151617181920212223242526/** * DeepClone */public class DeepClone implements Serializable&#123; private List&lt;String&gt; list; public List&lt;String&gt; getList() &#123; return list; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public DeepClone deepClone () throws IOException, ClassNotFoundException &#123; //将对象写入流 ByteArrayOutputStream bao = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bao); oos.writeObject(this); //将对象读出流 ByteArrayInputStream bai = new ByteArrayInputStream(bao.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bai); return (DeepClone)ois.readObject(); &#125;&#125; 客户端代码如下： 12345678910111213141516171819public class Client &#123; public static void main(String[] args) &#123; DeepClone dp0 = new DeepClone(); ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(3); list.add("1"); list.add("2"); list.add("3"); dp0.setList(list); try &#123; DeepClone dp1 = dp0.deepClone(); System.out.println(dp0 == dp1); //false System.out.println(dp0.getList() == dp1.getList()); //false &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 可以看到dp0.getList() == dp1.getList()结果为false,说明List拷贝成功。 总结缺点 需要为每个类提供Clone方法，比较麻烦。 实现深克隆比较麻烦，尤其是当对象存在多重嵌套时。 适用场景 创建对象成本较大时，可考虑用克隆模式来复制，减少系统资源占用。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2017%2F12%2F09%2FdesignPattern%2F4_sinleton_pattern%2F</url>
    <content type="text"><![CDATA[单例模式 概念 有时对于系统中某些类而言，不需要多个实体。一方面需要保证这个实体的“原子性”，另一方面也可以节省系统资源。比如对于游戏账号这个类来说，账号里某些信息是恒定不变的，用户上线下线登陆的还是那个账号，这时可以考虑单例模式。 定义： 单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 结构图如下： 实例对于单例模式而言，要求我们在系统中只能获得一个实例。很容易想到以下写法:12345678910111213141516/** * 有线程安全问题 */public class SimpleSingleton &#123; private static SimpleSingleton instance = null; private SimpleSingleton () &#123; &#125; public static SimpleSingleton getInstance () &#123; if (instance == null) &#123; instance = new SimpleSingleton(); &#125; return instance; &#125;&#125; 首先将此类构造器设置为访问权限设置为private，禁止外部创建此对象。然后建立个私有静态成员变量instance存储实例，最后建立共公有静态成员方法，返回实例。 但是在高并发访问环境下，还是可能会出现多个实例的情况。原因是当第一次调用getInstance()时并触发instance=null时，程序执行instance = new SimpleSingleton()，如果SimpleSingleton对象初始化时间足够长，并且外部又出现第二次调用getInstance()，此时由于SimpleSingleton对象还在初始化中，还是会触发instance=null，进入循环体第二次执行instance = new SimpleSingleton()。 下面介绍三种单例模式都可以从各方面来解决这个问题。 恶汉式单例类1234567891011121314/** * 饿汉单例 */public class EagerSinleton &#123; private final static EagerSinleton instance = new EagerSinleton(); private EagerSinleton () &#123; &#125; public static EagerSinleton getInstance() &#123; return instance; &#125;&#125; 恶汉单例模式主要是通过final关键字来实现的，当类EagerSinleton加载时静态变量instance执行初始化，final可以保证instance的指向不会改变。缺点是类加载时实例就会创建，可能会对系统资源开销造成影响。 懒汉式单例类 12345678910111213141516171819/** * 懒汉单例 */public class LazySinleton &#123; private volatile static LazySinleton instance = null; private LazySinleton () &#123; &#125; public static LazySinleton getInstance () &#123; if (instance == null) &#123; synchronized (LazySinleton.class) &#123; if (instance == null) &#123; instance = new LazySinleton(); &#125; &#125; &#125; return instance; &#125;&#125; 可以看到懒汉单例模式就是上述SimpleSingleton的线程安全版本。当需要此对象时对象才会被创建，也就是所谓的懒加载（LazyLoad）。 在getInstance方法中用synchronize关键字对LazySinleton.Class对象加锁，防止该对象同时被两个线程访问。instance采用volatile关键字修饰，保证此变量的对其他的线程可见性。多加了一层判断保证程序稳定性。缺点是必须处理线程锁，初次加载时可能消耗性能。 Initialization Demand Holder (IoDH)12345678910111213141516/** * Initialization Demand Holder (IoDH) */public class Singleton &#123; private Singleton () &#123; &#125; private static class HolderClass &#123; private final static Singleton instance = new Singleton(); &#125; public static Singleton getInstance () &#123; return HolderClass.instance; &#125;&#125; 上述单例采用静态内部类的方式来实现，依赖于java语言特性，将恶汉，懒汉特性结合。 总结缺点 职责过重，在一定程度上违背单一职责原则。 对于带GC回收机制的语言来说，长时间不用的对象有可能被回收，可能导致单例对象状态丢失。 适用场景 系统只需要一个实例]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2017%2F12%2F03%2FdesignPattern%2F3_abstract_factory_pattern%2F</url>
    <content type="text"><![CDATA[抽象工厂模式 概念工厂方法模式为了解决工厂类责任过重的问题，引入了工厂等级结构。但是工厂方法模式一个Factory类只生产一个产品，这样势必会造成类数目暴涨问题，带来额外系统开销。可以用抽象工厂模式来解决这个问题。 定义： 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式为创建一组对象提供了一种解决方案。 结构图如下： 实例上面的定义和结构图看着可能云里雾里的，直接看代码好了。以我喜欢吃的水果为例子。水果通常分果皮、果肉、果核。吃水果之前我们一般需要判断下哪部分可以吃… 首先建立Factory与Product接口123456789101112131415161718//水果工厂public interface FruitFactory &#123; public Peel createPeel(); public Flesh createFlesh(); public Kernel createKernel();&#125;//果皮public interface Peel &#123; public void isEat();&#125;//果肉public interface Flesh &#123; public void isEat();&#125;//果核public interface Kernel &#123; public void isEat();&#125; 接着建立ConcreteFactory 与ConcreteProcduct1234567891011121314151617181920212223242526272829303132333435public class AppleFactory implements FruitFactory &#123; @Override public Peel createPeel() &#123; return new ApplePeel(); &#125; @Override public Flesh createFlesh() &#123; return new AppleFlesh(); &#125; @Override public Kernel createKernel() &#123; return new AppleKernel(); &#125;&#125;public class ApplePeel implements Peel &#123; @Override public void isEat() &#123; System.out.println("苹果皮可以吃！"); &#125;&#125;public class AppleFlesh implements Flesh &#123; @Override public void isEat() &#123; System.out.println("苹果果肉可以吃！"); &#125;&#125;public class AppleKernel implements Kernel &#123; @Override public void isEat() &#123; System.out.println("苹果核不可以吃！"); &#125;&#125; 看下运行结果：123456789101112public class EatFruit &#123; public static void main(String[] args) &#123; FruitFactory fruit = new AppleFactory(); fruit.createPeel().isEat(); fruit.createFlesh().isEat(); fruit.createKernel().isEat(); &#125;&#125;运行结果：苹果皮可以吃！苹果果肉可以吃！苹果核不可以吃！ 总结可以看到抽象工厂模式是将一系列有共同特征的对象封装在一起（使用一个工厂来创建），将来系统扩展时也比较方便，有效地减少了程序中的类的数目。 但是也有缺点。就上例而言，假如我们要新增桃子类，写个1个桃子工厂类再写3个产品类就可以，不用修改已有代码，很方便，符合开闭原则。但是如果要新增香蕉类呢，香蕉没果核啊，是不是需要改动一系列接口？这个也是抽象工厂的最大的缺点了。可以说其满足纵向（产品族 ）的开闭原则，而不满足横向（产品等级）的开闭原则。具体应用场景视情况而定,不要生搬硬套。 缺点 更改产品等级比较麻烦，违反开闭原则 适用场景 具体产品在逻辑上属于同一产品族，具有共同约束，比如苹果、梨子都有果肉 产品等级比较稳定，不会对已有产品等级进行修改，比如系统需求稳定了，不会让你再往里加香蕉…]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2017%2F12%2F01%2FdesignPattern%2F2_factory_method_pattern%2F</url>
    <content type="text"><![CDATA[工厂方法模式 概念简单工厂模式已经了解过了，它的缺点也很明显：违背开闭原则，容易造成Factory类复杂度过大。工厂方法模式可以适当解决这些问题。 定义：工厂方法模式（Factory Method Pattern），定义一个创建对象的接口，让其子类来创建对象。结构图如下： 实例下面让我们将简单工厂中的例子改写下，将GirlFactory改为接口，额外添加三个工厂类。 123456789101112131415161718192021222324252627public interface GirlFactory &#123; public Girl createGirl();&#125;public class XiaoCaoFactory implements GirlFactory &#123; @Override public Girl createGirl() &#123; Girl xiaoCao = new XiaoCao(); return xiaoCao; &#125;&#125;public class XiaoHuaFactory implements GirlFactory &#123; @Override public Girl createGirl() &#123; Girl xiaoHua = new XiaoHua(); return xiaoHua; &#125;&#125;public class XiaoYeFactory implements GirlFactory &#123; @Override public Girl createGirl() &#123; Girl xiaoYe = new XiaoYe(); return xiaoYe; &#125;&#125; 同时将客户端类Mother调用方式改写下 1234567891011public class Mother &#123; public static void main(String[] args) &#123; GirlFactory factory= new XiaoCaoFactory();//可引入配置文件通过反射来实现 Girl girl = factory.createGirl(); girl.name(); girl.character(); &#125;&#125;运行结果：我是一个漂亮的，身材棒的女孩！我的名字是小花！ 可以看到运行结果不变，不过类的数目增加了3个（项目结构复杂了），这样做的好处在哪里？答案是解耦。我们可以想想，如果需要添加新的concreteProduct时，需要怎么做。 1.建立新的Girl类（concreteProduct），比如XiaoHong、XiaoJing，让它继承于Girl接口。2.建立新的Factory类（concreteFactory）,让它继承于GirlFactory接口,通过这个Factory类来建立Girl对象。3.改写客户端Mother，将Factory更换。 注意：在这个过程中我们并没有对原有的服务端类Factory和Product进行修改（Mother类属于客户端），而是通过java的多态特性根据需求对进行扩展（增加了concreteProduct类和concreteFactory类，没有改动原来服务端的代码，符合开闭原则，对修改关闭，对扩展开放）。 总结缺点 新增产品类时系统的类成对增加（concreteProduct与concreteFactory），增加系统的复杂度，额外的编译开销 适用场景 客户端不需知道类名，只需要知道工厂就可以 系统后续扩展趋势较大，用来保证系统解耦度]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2017%2F11%2F28%2FdesignPattern%2F1_simple_factory_pattern%2F</url>
    <content type="text"><![CDATA[简单工厂模式 使用工厂模式创建对象的好处通常我们在创建对象时最容易想到的就是new操作符，不过new操作符有许多局限：不够灵活，与业务类耦合度过大，也将初始化对象等无关业务细节暴露（我们只是要获取对象，不关心其他，初始化对象等细节操作何不交给其他类来完成？）。 一般可以采用工厂模式来解决这类问题。由一个第三方类（Factory类）来创建对象，将对象创建过程封装起来，降低系统耦合度。 概念简单工厂模式（Simple Factory Pattern）并不属于GoF23个经典设计模式，不过它是学习其他工厂模式的基础。概念也比较简单。 定义：定义一个工厂类，里面存在个static方法，根据不同参数返回不同实例，返回的实例通常具有共同父类。结构图如下： 实例下面来举个简单的例子吧。想必很多同学都被家里长辈唠叨过怎么还不找女朋友。那我们就拿这个事来举个简单工厂的例子吧。 首先编写Product与ConcreteProduct类： 1234567891011121314151617181920212223242526272829public abstract class Girl &#123; //女孩的品质 public void character() &#123; System.out.println("我是一个漂亮的，身材棒的女孩！"); &#125; //女孩的名字 public abstract void name ();&#125;public class XiaoCao extends Girl &#123; @Override public void name() &#123; System.out.println("我的名字是小草！"); &#125;&#125;public class XiaoHua extends Girl &#123; @Override public void name() &#123; System.out.println("我的名字是小花！"); &#125;&#125;public class XiaoYe extends Girl &#123; @Override public void name() &#123; System.out.println("我的名字是小叶！"); &#125;&#125; 可以看到，我们创建了一个抽象类，并用这个类实现了三个具体类。 假如你现在有三个女朋友（不是让你脚踏三只船，只是为了例子说明），Mother要看看她们。我们很容易就想到下面实现： 1234567891011public class Mother &#123; public static void main(String[] args) &#123; Girl girlFriend = new XiaoCao();//小草 girlFriend.character(); girlFriend.name(); &#125;&#125;运行结果：我是一个漂亮的，身材棒的女孩！我的名字是小草！ 看起来很棒，运行结果也没问题。不过Mother看完小草不是那么满意，又想看小花了。或者Father、Sister什么的七大姑八大姨都要来看。这可怎么办，只能修改Mother类了。难道每次换想法我都要改一次吗？有没有一种方法可以直接给他们想要的，需要什么就给什么。 我们可以建立一个Factory类，你想看哪个直接取就是了。 12345678910111213public class GirlFactory &#123; public static Girl getGrilFriend (String name) &#123; Girl girl = null; if (name.equals("小草")) &#123; girl = new XiaoCao(); &#125; else if (name.equals("小花")) &#123; girl = new XiaoHua(); &#125; else if (name.equals("小叶")) &#123; girl = new XiaoYe(); &#125; return girl; &#125;&#125; Mother类变为： 1234567891011public class Mother &#123; public static void main(String[] args) &#123; Girl girlFriend = GirlFactory.getGrilFriend("小花"); girlFriend.character(); girlFriend.name(); &#125;&#125;运行结果：我是一个漂亮的，身材棒的女孩！我的名字是小花！ 将创建对象的职责交给第三方类(Factory)来执行,来达到解耦合的目的。什么七大姑八大姨想看也直接从Factory里取就是了。 不过缺点想必大家也可以看出，如果需要增加新的ConcreteProduct类时必须修改Factory类，这违背了开闭原则。当需要创建的对象很多时也势必会增加Factory类的复杂度，所以它适用于需要用Factory类创建少量对象的场合。 总结缺点 Factory类负责相关所有对象的创建，职责过重，复杂度高 添加新产品时必须修改Factory类，违背开闭原则 适用场景 需要创建的对象不多时，Factory类复杂度不会太高 客户端只需要知道传入的参数，对如何创建对象并不关心]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的设计原则]]></title>
    <url>%2F2017%2F11%2F26%2FdesignPattern%2F0_design_pattern_principle%2F</url>
    <content type="text"><![CDATA[面向对象的设计原则 在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。下面简单阐述下各个设计原则的概念。 单一职责原则（Single Responsibility Principle, SRP） 定义：一个类只负责一个功能领域中的相应职责 理解： 类的设计不能太臃肿，避免造成不可复用、维护不便等问题。比如WEB系统MVC分层设计就包含了单一职责原则思想，DAO层可以被复用，也便于维护。 开闭原则（Open-Closed Principle, OCP） 定义：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 理解：抽象化是开闭原则的关键，类的结构设计应具有抽象化的思想，当增加修改时不应大幅度改变原代码结构。java抽象类与接口的概念符合开闭原则，当修改类功能时直接扩展基类就可以。 里氏代换原则（Liskov Substitution Principle, LSP） 定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。 理解：里氏代换原则是开闭原则的具体实现手段之一。在传递参数、声明类型、定义变量时都可使用里氏代换原则，也就是用基类（抽象类、接口）来定义类型，待到运行时才确定具体子类类型。 依赖倒转原则(Dependency Inversion Principle, DIP) 定义：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 理解：实现依赖倒转原则时，针对抽象编程。将具体类的对象通过依赖注入具体注入到其他对象中。（感觉与里氏代换原则很像，分不清…这里理解为里氏代换原则是基础，依赖倒转原则为具体实现） 接口隔离原则（Interface Segregation Principle, ISP） 定义：使用多个专门的接口，而不使用单一的总接口。 理解：接口的粒度必须控制得当，太小会使系统中接口暴增，不利于维护。太大则灵活性较差，且违背单一职责原则。 合成复用原则（Composite Reuse Principle, CRP） 定义：尽量使用对象组合，而不是继承来达到复用的目的。 理解：继承的依赖性相对较强，修改时牵一发而动全身。若两个类之间的关系不是严格的类别关系，而是某个点的职责关系，优先考虑使用合成复用原则。 迪米特法则（Law of Demeter, LoD） 定义： 一个软件实体应当尽可能少地与其他实体发生相互作用。 理解：当前类不要与没有直接关系的类进行消息传递。如必要可以使用中间类（Mediator）来达到松耦合的目的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2017%2F11%2F15%2Flinux%2Flinux_command%2F</url>
    <content type="text"><![CDATA[linux常用命令 基本操作快捷键 登录shell ctrl+shift+f1-f6 退出shell到图形页面 ctrl+shift+f7 命令补全 tab 暂停正在运行的shell程序执行 ctrl+c 注销shell执行（=exit） ctrl+d 基本操作命令行 修改shell支持语言 查看语言编码格式 echo $LANG 修改语言格式为英文 LANG=en_US 切换用户 su 查看日期 date 查看日历 cal 计算器 bc 显示小数位数（默认整数）sclae=n 离开计算器 quit 命令行帮助文档 man+命令行 将数据同步写入硬盘（一般root写入）*sync 关机 shutdown -h 立即关机 -r 立即重启 -k 只显示消息 shutdown -h +10/20:15 ‘we are readying the linux after 10min/ in 20:15’ 在10分钟后（或于20:15）关机，并且在当前登录此机器的用户屏幕前显示信息 文件系统检查 fsck 文件管理命令行 展示所有文件 ls -al 展示特定文件夹下文件 ls -l /../.. 改变文件用户组 chgrp groupname dirname/filename 改变文件所有者 chown ownname [:groupname] dirname/filename 改变文件权限 chmod numberList|chatList dirname/filename rwz三种权限对应数字分别为4 2 1,如果将test.text的权限修改为 rwxrxrw，命令也就是 chmod 756 test.text 也可以使用u g o通过+ - =操作符来修改 创建文件 touch dirname/filename 文件目录操作 特殊符号： 当前目录： .上层目录： ..前一个工作目录： -当前账户主目录： ~account账户主目录： ~ account 相关命令： 切换目录：cd 显示当前目录：pwd 创建目录： mkdir 删除目录：rmdir 移动文件：mv 删除文件：rm 新建文件： touch 赋予文件隐藏属性 ： chattr 新增环境变量：PATH=”$PATH”:/dirname 查找执行文件（PATH下）：which 查找特定文件: whereis 查找本地文件：locate(可使用updatedb更新下数据文件再查找，比较耗时) 详细检索文件(磁盘检索): find 查看文件系统属性: dumpe2fs 查看当前使用的文件系统: df 查看文件系统详情: du 磁盘操作: fdisk (使用前需用df命令找到文件系统路径) 磁盘格式化: mkfs 挂载命令: mount 检查文件系统:fsck 文件压缩：gzip (.gz)、bzip2(.bz2) 打包压缩（z代表gzip,j代表bzip2）tar -zpcv -f /root/etc.tar.gz /etc 查看压缩文件 tar -ztv -f /root/etc.tar.gz 解压缩到指定文件夹 tar -zxv -f /root/etc.tar.gz -C /tmp bash相关命令 查看环境变量：env 或 set 取消环境变量 : unset 变量键盘读取 : read 声明变量类型 : declare或typeset 直接写入配置文件: source 或 . 特殊符号 以覆盖的方法将正确的数据输出：1&gt; 以累加的方法将正确的数据输出： 1&gt;&gt; 以覆盖的方法将错误的数据输出：2&gt; 以累加的方法将错误的数据输出：2&gt;&gt; 标准输入源 : &lt; 标准输入源结束标志 : &lt;&lt; 管道命令 分割字符 ： cut 匹配对应行：grep 排序：sort 去重 ：uniq 统计: wc 截取数据流重定向：tee 替换，删除字符串 : tr 过滤控制字符：col 多文件相关栏位联结：join 多文件相关栏位粘贴：paste tab转空格：expand -t 切割文件 ： split -b 一般命令参数代换为管道命令： xargs 常用处理工具：sed，printf, awk]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux VIM编辑器快捷键]]></title>
    <url>%2F2017%2F11%2F09%2Flinux%2Flinux_vim%2F</url>
    <content type="text"><![CDATA[linux VIM编辑器快捷键基本操作 i 一般模式进入编辑模式 esc 退出编辑模式到一般模式 :wq 一般模式下退出vim编辑器并保存更改 移动光标 h 或 ← 向左移动一个字符 j 或 ↓ 向下移动一个字符 k 或 ↑ 向上移动一个字符 l 或 → 向右移动一个字符 多次操作采用 数字+快捷键,例如向上移动10个字符可用 10+k 快捷键 ctrl+f 或 PageDown 向下移动一页 【常用】 ctrl+b 或 PageUp 向上移动一页 【常用】 ctrl+d 向下移动半页 ctrl+u 向上移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n[space] 光标向右移动n个距离 0 或 home 光标移动至行首 【常用】 $ 或 end 光标移动至行尾 【常用】 H 光标移动至当前屏幕区域首行 M 光标移动至当前屏幕区域中间行 L 光标移动至当前屏幕区域尾行 G 光标移动至当前文件的尾行 【常用】 nG 光标移动至当前文件的第n行 gg 光标移动至当前文件的第1行【常用】 查找与替换 /word 向下寻找名为word的字符串【常用】 ?word 向上寻找名为word的字符串 n 重复前一个查找操作 N 反向重复前一个查找操作 :n1,n2s/word1/word2/g n1行到n2行将word1替换word2【常用】 :1,$s/word1/word2/g第一行到最后一行将word1替换word2【常用】 :1,$s/word1/word2/gc第一行到最后一行将word1替换word2，并提示是否操作【常用】 删除与复制粘贴 x,X 向后（前）删除一个字符【常用】 nx 向后删除n个字符【常用】 nx 向后删除n个字符 dd 删除光标所在那一整行 ndd 删除光标所在下n整行 d1G 删除光标所在到第一行的所有数据 dG 删除从光标所在到最后一行的所有数据 d$ 删除从光标所在处到该行的最后一个字符 d0 删除从光标所在处到该行的最前面一个字符 yy 复制光标所在的那一行【常用】 nyy 复制光标所在的向下n行【常用】 y1G 复制光标所在行到第一行的所有数据 yG 复制光标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p,P 向下粘贴（向上粘贴）【常用】 J 将光标所在行与下一行的数据结合成同一行 u 复原前一个操作【常用】 ctrl+r 重做前一个操作【常用】 . 重复前一个操作【常用】 :!command 暂时离开 vi到命令行模式下执行 command 的显示结果 编辑模式进入插入模式（Insert mode）： i，I i为从目前光标所在处插入，I为在目前所在行的第一个非空格符处开始插入【常用】 a，A a 为从目前光标所在的下一个字符处开始插入，A 为从光标所在行的最后一个字符处开始插入【常用】 o，O o 为在目前光标所在的下一行处插入新的一行；O 为在目前光标所在处的上一行插入新的一行【常用】 进入替换模式（Replace mode）： r，R r 只会替换光标所在的那一个字符一次；R 会一直替换光标所在的文字，直到按下[Esc]键为止【常用】]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用excel导出demo]]></title>
    <url>%2F2017%2F05%2F03%2FcodeExample%2Fexcel_export_byReflect%2F</url>
    <content type="text"><![CDATA[通用excel导出demo（利用反射）最近项目后台管理系统好多地方都要用到excel导出。考虑到一次次修改原代码太无聊，各方面拼拼凑凑写出个通用类，传几个参数设定下表头就ok了。对反射的概念和相关api了解又加深了点…代码记录如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import org.apache.poi.hssf.usermodel.*;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;public class PoiTool &#123; /** * * @param list 数据源list * @param beanClass list中Object的Class对象 * @param map 表头名与对应字段集合（需预定义，例&#123;&lt;用户名,username&gt;&lt;密码，password&gt;&#125;） * @param response 响应对象 * @throws IllegalAccessException * @throws InstantiationException * @throws InvocationTargetException */ public static void exportExcel(List list, Class beanClass, LinkedHashMap&lt;String, String&gt; map, HttpServletResponse response) throws IllegalAccessException, InstantiationException, InvocationTargetException &#123; int j = 0; String valueStr = ""; HSSFWorkbook wb = new HSSFWorkbook(); HSSFSheet sheet = wb.createSheet("sheet1"); HSSFCellStyle style = wb.createCellStyle();//样式 style.setAlignment(HSSFCellStyle.ALIGN_CENTER); HSSFRow row = sheet.createRow(0);//第一行 for (Map.Entry&lt;String, String&gt; m : map.entrySet()) &#123;//导入excel表头 HSSFCell cell = row.createCell(j); cell.setCellValue(m.getKey()); cell.setCellStyle(style); sheet.autoSizeColumn(j); valueStr += m.getValue() + "|";//filed字符串 j++; &#125; valueStr = valueStr.substring(0, valueStr.length() - 1); System.out.println(valueStr); String[] valueArray = valueStr.split("\\|");//filed数组 //通过反射获取对应beanClass中的字段 //并将其转为get方法置入集合中 Field field[] = beanClass.getDeclaredFields(); List&lt;Method&gt; methodlist = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; field.length; i++) &#123; String fieldName = field[i].getName(); StringBuffer methodName = new StringBuffer("get"); methodName.append(fieldName.substring(0, 1).toUpperCase()); methodName.append(fieldName.substring(1)); Method getMethod = null; try &#123; getMethod = beanClass.getMethod(methodName.toString()); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; methodlist.add(getMethod); &#125; //遍历list，并插入数据 for (int i = 0; i &lt; list.size(); i++) &#123; row = sheet.createRow(i + 1);//创建行，从第二行开始 for (int k = 0; k &lt; valueArray.length; k++) &#123;//遍历column Method getMethod = getCurrentMethod(valueArray[k], methodlist);//获取colunm对应的get方法 if (getMethod.getReturnType().toString().indexOf("int") &gt;= 0) &#123; row.createCell(k).setCellValue((int) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; else if (getMethod.getReturnType().toString().indexOf("String") &gt;= 0) &#123; row.createCell(k).setCellValue((String) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; else if (getMethod.getReturnType().toString().indexOf("double") &gt;= 0) &#123; row.createCell(k).setCellValue((double) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; else if (getMethod.getReturnType().toString().indexOf("float") &gt;= 0) &#123; row.createCell(k).setCellValue((float) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; &#125; sheet.autoSizeColumn(i); &#125; response.reset(); response.setContentType("application/vnd.ms-excel;charset=gb2312"); response.setHeader("Content-disposition", "attachment;filename=excel.xls"); try &#123; OutputStream outputStream = response.getOutputStream(); wb.write(outputStream); wb.close(); outputStream.flush(); outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //获取当前column的get方法 public static Method getCurrentMethod(String valueArray, List&lt;Method&gt; methodlist) &#123; if (valueArray != null &amp;&amp; methodlist.size() &gt; 0) &#123; for (int i = 0; i &lt; methodlist.size(); i++) &#123; if (methodName(methodlist.get(i).getName()).equals(valueArray)) &#123; return methodlist.get(i); &#125; &#125; &#125; return null; &#125; //处理methodName public static String methodName(String str) &#123; if (str != null) &#123; str = str.substring(3).substring(0, 1).toLowerCase() + str.substring(3).substring(1); return str; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众平台普通红包发放]]></title>
    <url>%2F2017%2F04%2F25%2Fwexin%2Fweixin_web_OrdinaryRedPacket%2F</url>
    <content type="text"><![CDATA[业务需求：在后台管理系统为微信用户发放红包，弄了好几天总算搞定了，需要注意的是获取签名部分，流程大体如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210//红包业务方法public int sendRedpack(HttpServletRequest request,UserAverage userAverage) throws Exception &#123; WechatInfo wechat = getWechatInfo(request); WechatInfo wechatInfo = wechatInfoService.queryWechatinfo(wechat.getAppid()); String sendName =wechatInfo.getWxname(); //微信证书路径 String certPath =this.getClass().getResource("/").getPath()+"xxxxx/apiclient_cert.p12"; certPath = URLDecoder.decode(certPath,"UTF-8");//证书路径解码 logger.info("证书路径:"+certPath); //商户id String wxappid = wechatInfo.getAppid(); // 微信支付分配的商户号 String partner = wechatInfo.getPartnerid(); //API密钥 String paternerKey =wechatInfo.getPartnerkey(); /** * 发送普通红包 */ boolean isSend = sendredpack(wechatInfo,request, "100", "1", "恭喜您获得竞赛奖金！", "竞赛答题活动", "竞赛奖金", userAverage.getOpenid(), partner, wxappid, sendName, paternerKey, certPath); if(!isSend)&#123; return 0; &#125; return 1;&#125;// 主封装方法// * @param request 获取IP// * @param total_amount 付款现金(单位分)// * @param total_num 红包发放总人数// * @param wishing 红包祝福语// * @param act_name 活动名称// * @param remark 备注// * @param reOpenid 用户openid// * @param partner 商户号// * @param wxappid 公众账号appid// * @param sendName 商户名称// * @param paternerKey 商户签名key// * @param certPath 证书路径// * @return// */ public static boolean sendredpack(WechatInfo wechatInfo,HttpServletRequest request,String total_amount,String total_num,String wishing,String act_name,String remark,String reOpenid,String partner,String wxappid,String sendName,String paternerKey,String certPath) throws Exception&#123; // 商户订单号 String mchBillno = RedPackUtil.createBillNo(wechatInfo); String ip ="xxx.xx.xxx.xx";//服务器IP Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(); // 随机字符串 params.put("nonce_str", RedPackUtil.createNonce_str()); // 商户订单号 params.put("mch_billno", mchBillno); // 商户号 params.put("mch_id", partner); // 公众账号ID params.put("wxappid", wxappid); // 商户名称 params.put("send_name", sendName); // 用户OPENID params.put("re_openid", reOpenid); // 付款现金(单位分) params.put("total_amount", total_amount); // 红包发放总人数 params.put("total_num", total_num); // 红包祝福语 params.put("wishing", wishing); // 终端IP params.put("client_ip", ip); // 活动名称 params.put("act_name", act_name); // 备注 params.put("remark", remark); //创建签名 String sign = RedPackUtil.redSignal(params, paternerKey); logger.info("md5签名："+sign); params.put("sign", sign); String xmlResult = RedPackUtil.sendRedPack(params, certPath, partner);//执行发送红包 logger.info("发送红包返回结果："+xmlResult.toString()); Map&lt;String, String&gt; result = XMLUtil.xml2Map(xmlResult); logger.info("红包参数："+result.toString()); //此字段是通信标识，非交易标识，交易是否成功需要查看result_code来判断 String return_code = result.get("return_code"); //业务结果 String result_code = result.get("result_code"); if (StringUtils.isNotBlank(return_code) &amp;&amp; "SUCCESS".equals(return_code)) &#123; logger.info("通信成功return_code："+return_code); if (StringUtils.isNotBlank(result_code) &amp;&amp; "SUCCESS".equals(result_code)) &#123; logger.info("发送成功result_code："+result_code); return true; &#125;else&#123; logger.info("发送失败result_code："+result_code); &#125; &#125;else&#123; logger.info("通信失败return_code："+return_code); &#125; return false; &#125; /** * 生成商户订单号 * @param mch_id 商户号 * @param userId 该用户的userID * @return */public static String createBillNo(WechatInfo wechatInfo)&#123; //组成： mch_id+yyyymmdd+10位一天内不能重复的数字 //10位一天内不能重复的数字实现方法如下: //因为每个用户绑定了userId,他们的userId不同,加上随机生成的(10-length(userId))可保证这10位数字不一样 Date dt=new Date(); SimpleDateFormat df = new SimpleDateFormat("yyyymmdd"); String nowTime= df.format(dt); int length = 10 ; return wechatInfo.getPartnerid() + nowTime + getRandomNum(length);&#125;/** * 生成红包参数随机数nonce_str * @return */public static String createNonce_str()&#123; return System.currentTimeMillis()/1000+getRandomNum(5);&#125;/** * 生成特定位数的随机数字 * @param length * @return */public static String getRandomNum(int length) &#123; String val = ""; Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; val += String.valueOf(random.nextInt(10)); &#125; return val;&#125;/*** @Title: redSignal * @Description: 发送红包签名生成* @param @param params* @param @return 设定文件 * @return String 返回类型 * @throws*/public static String redSignal(Map&lt;String, String&gt; params,String paternerKey) &#123;SortedMap&lt;String, String&gt; packageParams = new TreeMap&lt;String, String&gt;();for (Map.Entry&lt;String, String&gt; m : params.entrySet()) &#123;packageParams.put(m.getKey(), m.getValue().toString());&#125;StringBuffer sb = new StringBuffer();Set&lt;?&gt; es = packageParams.entrySet();Iterator&lt;?&gt; it = es.iterator();while (it.hasNext()) &#123;Map.Entry entry = (Map.Entry) it.next();String k = (String) entry.getKey();String v = (String) entry.getValue();if (!StringUtils.isEmpty(v) &amp;&amp; !"sign".equals(k) &amp;&amp; !"key".equals(k)) &#123;sb.append(k + "=" + v + "&amp;");&#125;&#125;sb.append("key=" + paternerKey);System.out.println("未加密签名："+sb.toString());String sign = MD5Util.MD5Encode(sb.toString(),"UTF-8").toUpperCase();return sign;&#125;private static String sendRedPackUrl = "https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack";/** * 发送红包 * @param params 请求参数 * @param certPath 证书文件目录 * @param partner 证书密码 * @return &#123;String&#125; * @throws Exception */public static String sendRedPack(Map&lt;String, String&gt; params, String certPath, String partner) throws Exception &#123; return doSend(sendRedPackUrl, XMLUtil.map2Xmlstring(params), certPath, partner);&#125;public static String doSend(String url, String data , String certPath , String partner) throws Exception &#123; KeyStore keyStore = KeyStore.getInstance("PKCS12"); FileInputStream instream = new FileInputStream(new File(certPath));//P12文件目录 try &#123; keyStore.load(instream, partner.toCharArray());//这里写密码..默认是你的MCHID &#125; finally &#123; instream.close(); &#125; SSLContext sslcontext = SSLContexts.custom() .loadKeyMaterial(keyStore, partner.toCharArray())//这里也是写密码的 .build(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] &#123; "TLSv1" &#125;, null, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER); CloseableHttpClient httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build(); try &#123; HttpPost httpost = new HttpPost(url); // 设置响应头信息 httpost.addHeader("Connection", "keep-alive"); httpost.addHeader("Accept", "*/*"); httpost.addHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"); httpost.addHeader("Host", "api.mch.weixin.qq.com"); httpost.addHeader("X-Requested-With", "XMLHttpRequest"); httpost.addHeader("Cache-Control", "max-age=0"); httpost.addHeader("User-Agent", "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) "); httpost.setEntity(new StringEntity(data, "UTF-8")); CloseableHttpResponse response = httpclient.execute(httpost); try &#123; HttpEntity entity = response.getEntity(); String jsonStr = toStringInfo(response.getEntity(),"UTF-8"); EntityUtils.consume(entity); return jsonStr; &#125; finally &#123; response.close(); &#125; &#125; finally &#123; httpclient.close(); &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序支付接口二次签名]]></title>
    <url>%2F2017%2F04%2F12%2Fwexin%2Fweixin_miniProgram_sign%2F</url>
    <content type="text"><![CDATA[今天小程序的支付接口遇到签名错误问题。折腾半天…原因是：小程序支付的签名需要进行2次！！！不是成功获取订单后微信服务器回调的xml中的那个sign。 接口返回下列参数供小程序调用1234paySign //签名 prePay.getMiniPackage(prepayid));timeStamp //时间戳 prePay.getTimeStamp());nonceStr//随机签名 prePay.getNonce_str()); package//预支付订单，格式为prepay_id=*; 其中主要参数 paySign，是二次签名。具体签名参数 是采用 调用微信接口获取到预支付订单prepayid后服务器返回的参数（包括小程序需要调用的nonceStr,prepay_id）， 主要用下列参数生成paySign，语法如下：1appId=【appid】&amp;nonceStr=【随机字符串】&amp;package=prepay_id=【返回的prepay_id】&amp;signType=MD5&amp;timeStamp=【时间戳】&amp;key=【支付秘钥】 二次签名代码如下：12345678910111213141516171819public String getMiniPackage(String prepay_id) &#123; TreeMap&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;(); String timeStamp=OrderUtil.GetTimestamp(); setTimeStamp(timeStamp); treeMap.put("appId", this.appid); treeMap.put("nonceStr", getNonce_str()); treeMap.put("package", "prepay_id="+prepay_id); treeMap.put("signType", "MD5"); treeMap.put("timeStamp",timeStamp); StringBuilder sb = new StringBuilder(); for (String key : treeMap.keySet()) &#123; sb.append(key).append("=").append(treeMap.get(key)).append("&amp;"); &#125; sb.append("key=" + partnerKey); System.out.println("小程序二次签名："+sb.toString()); sign = MD5Util.MD5Encode(sb.toString(), "utf-8").toUpperCase(); return sign;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础概念与语法]]></title>
    <url>%2F2016%2F05%2F23%2Fdatabase%2Fmysql_base%2F</url>
    <content type="text"><![CDATA[由于没有系统学过mysql，之前自己看的相关ppt资料也是囫囵吞枣式的，对视图、游标、事物什么的理解都不是很深刻。特意找了本基础的书（《mysql必知必会》）看了下。 常用命令关键词 登录账户：mysql -u username显示库的信息：show databases操作库之前选择对应的库：use database_name显示库中的表： show tables显示表的列： show columns from table_name 或 describe table_name正则表达式查找： REGEXP （用法同LIKE，只不过关键词右边跟的是正则串） mysql函数 字符串 字符串连接： concat(str…)串左边字符： left(str，len)串右边字符： right(str，len)串长度：length(str)字串位置 ： locate(substr，str)将串转小写：lower(str)将串转大写：upper(str)去全部空格：trim(str)去左边空格：ltrim(str)去右边空格：rtrim(str)返回子串：substirng(str FROM pos FOR len)soundex发音值：soundex(str) 日期 增加时间：Date_add(date，interval expr type)当前日期+时间：now()当前日期：curdate()当前时间：curtime()返回日期部分：Date(expr)返回时间部分：Time(expr)返回年份部分：year(expr)返回月份部分：month(expr)返回天数部分：day(expr)返回分钟部分：month(expr)返回秒数部分：second(expr)返回日期之差(result_type：day)：dateDiff(expr1，expr2)时间格式化：date_format(date,format)返回星期几：dayOfWeek(date) [1=星期日，2=星期一…7=星期六] 全文本查找 需要为被搜索列建立FULLTEXT索引，并且引擎为MYISAM; 建表语句例如：12345678CREATE TABLE test( id int NOT NULL AUTO_INCREMENT, msg text NULL, PRIMARY KEY (id), FULLTEXT(msg))ENGINE=MYISAM; 文本查找语句则为：1select msg from test where Match(msg) against("xiaoqiang"); 视图 主要用来简化复杂查询语句，创建可重用的 “sql查询接口”，至于更新操作（包括插入，删除）则取决于视图建立条件，如果采用聚合函数、group by等就不允许更新。（更新视图实质上是对原表进行更新，不确定具体字段 自然不会允许更新） 创建视图：1CREATE VIEW `exam_view` AS select * from `exam` where appid = 'xxxxxxx'; 存储过程 实质上是sql中的函数，主要用于处理复杂的sql业务（高效，安全）。例如用户商品下单时对库存商品进行一系列处理，检查商品，预定商品，更新库存数目等等 一系列流程就可采用存储过程实现。 创建过程中IN代表函数接收参数，OUT是返回结果，INOUT则复合了IN、OUT的特性。 显示存储过程信息： 12SHOW CREATE PROCEDURE processName;SHOW PROCEDURE STATUS [LIKE processName]; 创建存储过程: 1234CREATE PROCEDURE queryEnameByEid(IN eid_Para INT,OUT ename_result VARCHAR(100)) BEGIN SELECT ename FROM exam WHERE eid=eid_Para INTO ename_result;END; 执行存储过程： 1CALL processName(30,@ename_result); 调用函数结果： 1SELECT @ename_result; 游标 实质上是存储了数据序列的结果集，在mysql中只能用于存储过程中 1234567891011121314151617181920212223242526BEGIN -- 声明局部变量 DECLARE flag INT DEFAULT 0; DECLARE tmp_value VARCHAR(50); -- 声明游标 DECLARE my_cursor CURSOR FOR (SELECT ename FROM exam); -- 建表 CREATE TABLE IF NOT EXISTS test_cursor(id int AUTO_INCREMENT,ename VARCHAR(50),PRIMARY KEY(id)); -- 开启游标 OPEN my_cursor; -- 循环开始 REPEAT -- 将游标获取的值放局部变量里 FETCH my_cursor INTO tmp_value; -- 更改flag值 SET flag=flag+1; -- 插入语句 INSERT INTO test_cursor(ename) VALUES(tmp_value); -- 游标到10时结束循环 UNTIL flag=10 END REPEAT; -- 打印表数据 SELECT * FROM test_cursor; -- 关闭游标 CLOSE my_cursor; END 触发器 将事件与sql执行状况绑定,可使用NEW、OLD虚拟表访问具体操作的字段值 12CREATE TRIGGER delete_question_msg AFTER DELETE ON questionFOR EACH ROW SELECT 'delete question finished!' INTO @msg; 12DELETE FROM question WHERE qid=528;SELECT @msg;]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基础符号概念]]></title>
    <url>%2F2016%2F05%2F17%2Fregx%2Fregx_base%2F</url>
    <content type="text"><![CDATA[在项目中解析文件部分使用java Pattern与Matcher类，自然少不了正则啦，在此将正则基础符号概念部分总结一下，比较精简… 句点符号. 任意单个字符 例：a.b 匹配三位长度字符串，中间任意字符；如a b，a1b，a-b等 方括号 圆括号[] 单字符长度范围， () 分组（不限长度） 例：a[123]b 匹配三位长度字符串，中间指定字符；如a1b,a2b,a3b，()用法同理 或符号| 或运算 例：(a|b|cc) 匹配a或b或cc，此处不可使用 [] 星号* 匹配左边字符0次或多次 例：a*[b] 匹配最后一位字符是b,前面字符全为a的字串或单个b字符，如ab，aaab，b 加号+ 匹配左边字符1次或多次 例: a+[b] 匹配第二位是b字符，b字符前面一个或多个a字符的字符串，如aab，ab,aaab 问号\? 匹配左边字符0次或一次（有或无此字符-&gt;有此字符也满足条件） 例：a?[ab] 匹配左边有a字符或无a字符，第二位为a或b的字符串，如a，ab，b 花括号{n} | {m-n} 匹配左边字符恰好n次 或 m-n 次（连续性） 例：a{3}b只匹配字符串aaab 否符号^ 非运算 例：[^a]b匹配第一个字符不是a，第二个字符是b的字符串 常用正则表达式符号\s 等价于 [\t\n\r\f] 即tab制表符、换行符、回车符、换页符，其一，也就是空白字符 \d等价于 [0-9] 也就是数字字符 \w等价于 [A-Z0-9] 也就是字符，字母字符无论大小写都匹配哦 \S \D \W 即上面三种符号定义的“非”逻辑]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>regx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决url传中文参数乱码]]></title>
    <url>%2F2016%2F03%2F23%2FfixBug%2FURL_ChineseParameter_MessyCode%2F</url>
    <content type="text"><![CDATA[解决url传中文参数乱码首先在前台js内将相应的中文参数（qsInfo）编码两次，相应代码如下。可用encodeURIComponent直接对中文参数进行编码，直接使用encodeURIComponent对url进行编码会使 / 字符转为16进制字符，这时你会发现页面没有定向到url的地址…1234var url=encodeURI(encodeURI('$&#123;ctx&#125;/backstage/getPraxisQuestionList?qsInfo='+qsInfo));or...var url='$&#123;ctx&#125;/backstage?qsInfo='+encodeURIComponent(encodeURIComponent(qsInfo));//var url=encodeURIComponent(encodeURIComponent('$&#123;ctx&#125;/backstage?qsInfo='+qsInfo));//url不跳转，/被编码了... 接着在java后台对相应字符进行解码就ok啦，代码如下 1String qsInfo = URLDecoder.decode(question.getQsInfo(),"UTF-8");//字符解码,此处我的参数是直接封装在bean里的。 具体流程就是：前台编码2次，后台解码1次…]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
</search>
