<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2017%2F12%2F09%2FdesignPattern%2Fsinleton_pattern%2F</url>
    <content type="text"><![CDATA[单例模式 概念 有时对于系统中某些类而言，不需要多个实体。一方面需要保证这个实体的“原子性”，另一方面也可以节省系统资源。比如对于游戏账号这个类来说，账号里某些信息是恒定不变的，用户上线下线登陆的还是那个账号，这时可以考虑单例模式。 定义： 单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 结构图如下： 实例对于单例模式而言，要求我们在系统中只能获得一个实例。很容易想到以下写法:12345678910111213141516/** * 有线程安全问题 */public class SimpleSingleton &#123; private static SimpleSingleton instance = null; private SimpleSingleton () &#123; &#125; public static SimpleSingleton getInstance () &#123; if (instance == null) &#123; instance = new SimpleSingleton(); &#125; return instance; &#125;&#125; 首先将此类构造器设置为访问权限设置为private，禁止外部创建此对象。然后建立个私有静态成员变量instance存储实例，最后建立共公有静态成员方法，返回实例。 但是在高并发访问环境下，还是可能会出现多个实例的情况。原因是当第一次调用getInstance()时并触发instance=null时，程序执行instance = new SimpleSingleton()，如果SimpleSingleton对象初始化时间足够长，并且外部又出现第二次调用getInstance()，此时由于SimpleSingleton对象还在初始化中，还是会触发instance=null，进入循环体第二次执行instance = new SimpleSingleton()。 下面介绍三种单例模式都可以从各方面来解决这个问题。 恶汉式单例类1234567891011121314/** * 饿汉单例 */public class EagerSinleton &#123; private final static EagerSinleton instance = new EagerSinleton(); private EagerSinleton () &#123; &#125; public static EagerSinleton getInstance() &#123; return instance; &#125;&#125; 恶汉单例模式主要是通过final关键字来实现的，当类EagerSinleton加载时静态变量instance执行初始化，final可以保证instance的指向不会改变。缺点是类加载时实例就会创建，可能会对系统资源开销造成影响。 懒汉式单例类 12345678910111213141516171819/** * 懒汉单例 */public class LazySinleton &#123; private volatile static LazySinleton instance = null; private LazySinleton () &#123; &#125; public static LazySinleton getInstance () &#123; if (instance == null) &#123; synchronized (LazySinleton.class) &#123; if (instance == null) &#123; instance = new LazySinleton(); &#125; &#125; &#125; return instance; &#125;&#125; 可以看到懒汉单例模式就是上述SimpleSingleton的线程安全版本。当需要此对象时对象才会被创建，也就是所谓的懒加载（LazyLoad）。 在getInstance方法中用synchronize关键字对LazySinleton.Class对象加锁，防止该对象同时被两个线程访问。instance采用volatile关键字修饰，保证此变量的对其他的线程可见性。多加了一层判断保证程序稳定性。缺点是必须处理线程锁，初次加载时可能消耗性能。 Initialization Demand Holder (IoDH)12345678910111213141516/** * Initialization Demand Holder (IoDH) */public class Singleton &#123; private Singleton () &#123; &#125; private static class HolderClass &#123; private final static Singleton instance = new Singleton(); &#125; public static Singleton getInstance () &#123; return HolderClass.instance; &#125;&#125; 上述单例采用静态内部类的方式来实现，依赖于java语言特性，将恶汉，懒汉特性结合。 总结缺点 职责过重，在一定程度上违背单一职责原则。 对于带GC回收机制的语言来说，长时间不用的对象有可能被回收，可能导致单例对象状态丢失。 适用场景 系统只需要一个实例]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2017%2F12%2F03%2FdesignPattern%2Fabstract_factory_pattern%2F</url>
    <content type="text"><![CDATA[抽象工厂模式 概念工厂方法模式为了解决工厂类责任过重的问题，引入了工厂等级结构。但是工厂方法模式一个Factory类只生产一个产品，这样势必会造成类数目暴涨问题，带来额外系统开销。可以用抽象工厂模式来解决这个问题。 定义： 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式为创建一组对象提供了一种解决方案。 结构图如下： 实例上面的定义和结构图看着可能云里雾里的，直接看代码好了。以我喜欢吃的水果为例子。水果通常分果皮、果肉、果核。吃水果之前我们一般需要判断下哪部分可以吃… 首先建立Factory与Product接口123456789101112131415161718//水果工厂public interface FruitFactory &#123; public Peel createPeel(); public Flesh createFlesh(); public Kernel createKernel();&#125;//果皮public interface Peel &#123; public void isEat();&#125;//果肉public interface Flesh &#123; public void isEat();&#125;//果核public interface Kernel &#123; public void isEat();&#125; 接着建立ConcreteFactory 与ConcreteProcduct1234567891011121314151617181920212223242526272829303132333435public class AppleFactory implements FruitFactory &#123; @Override public Peel createPeel() &#123; return new ApplePeel(); &#125; @Override public Flesh createFlesh() &#123; return new AppleFlesh(); &#125; @Override public Kernel createKernel() &#123; return new AppleKernel(); &#125;&#125;public class ApplePeel implements Peel &#123; @Override public void isEat() &#123; System.out.println(&quot;苹果皮可以吃！&quot;); &#125;&#125;public class AppleFlesh implements Flesh &#123; @Override public void isEat() &#123; System.out.println(&quot;苹果果肉可以吃！&quot;); &#125;&#125;public class AppleKernel implements Kernel &#123; @Override public void isEat() &#123; System.out.println(&quot;苹果核不可以吃！&quot;); &#125;&#125; 看下运行结果：123456789101112public class EatFruit &#123; public static void main(String[] args) &#123; FruitFactory fruit = new AppleFactory(); fruit.createPeel().isEat(); fruit.createFlesh().isEat(); fruit.createKernel().isEat(); &#125;&#125;运行结果：苹果皮可以吃！苹果果肉可以吃！苹果核不可以吃！ 总结可以看到抽象工厂模式是将一系列有共同特征的对象封装在一起（使用一个工厂来创建），将来系统扩展时也比较方便，有效地减少了程序中的类的数目。 但是也有缺点。就上例而言，假如我们要新增桃子类，写个1个桃子工厂类再写3个产品类就可以，不用修改已有代码，很方便，符合开闭原则。但是如果要新增香蕉类呢，香蕉没果核啊，是不是需要改动一系列接口？这个也是抽象工厂的最大的缺点了。可以说其满足纵向（产品族 ）的开闭原则，而不满足横向（产品等级）的开闭原则。具体应用场景视情况而定,不要生搬硬套。 缺点 更改产品等级比较麻烦，违反开闭原则 适用场景 具体产品在逻辑上属于同一产品族，具有共同约束，比如苹果、梨子都有果肉 产品等级比较稳定，不会对已有产品等级进行修改，比如系统需求稳定了，不会让你再往里加香蕉…]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2017%2F12%2F01%2FdesignPattern%2Ffactory_method_pattern%2F</url>
    <content type="text"><![CDATA[工厂方法模式 概念简单工厂模式已经了解过了，它的缺点也很明显：违背开闭原则，容易造成Factory类复杂度过大。工厂方法模式可以适当解决这些问题。 定义：工厂方法模式（Factory Method Pattern），定义一个创建对象的接口，让其子类来创建对象。结构图如下： 实例下面让我们将简单工厂中的例子改写下，将GirlFactory改为接口，额外添加三个工厂类。 123456789101112131415161718192021222324252627public interface GirlFactory &#123; public Girl createGirl();&#125;public class XiaoCaoFactory implements GirlFactory &#123; @Override public Girl createGirl() &#123; Girl xiaoCao = new XiaoCao(); return xiaoCao; &#125;&#125;public class XiaoHuaFactory implements GirlFactory &#123; @Override public Girl createGirl() &#123; Girl xiaoHua = new XiaoHua(); return xiaoHua; &#125;&#125;public class XiaoYeFactory implements GirlFactory &#123; @Override public Girl createGirl() &#123; Girl xiaoYe = new XiaoYe(); return xiaoYe; &#125;&#125; 同时将客户端类Mother调用方式改写下 1234567891011public class Mother &#123; public static void main(String[] args) &#123; GirlFactory factory= new XiaoCaoFactory();//可引入配置文件通过反射来实现 Girl girl = factory.createGirl(); girl.name(); girl.character(); &#125;&#125;运行结果：我是一个漂亮的，身材棒的女孩！我的名字是小花！ 可以看到运行结果不变，不过类的数目增加了3个（项目结构复杂了），这样做的好处在哪里？答案是解耦。我们可以想想，如果需要添加新的concreteProduct时，需要怎么做。 1.建立新的Girl类（concreteProduct），比如XiaoHong、XiaoJing，让它继承于Girl接口。2.建立新的Factory类（concreteFactory）,让它继承于GirlFactory接口,通过这个Factory类来建立Girl对象。3.改写客户端Mother，将Factory更换。 注意：在这个过程中我们并没有对原有的服务端类Factory和Product进行修改（Mother类属于客户端），而是通过java的多态特性根据需求对进行扩展（增加了concreteProduct类和concreteFactory类，没有改动原来服务端的代码，符合开闭原则，对修改关闭，对扩展开放）。 总结缺点 新增产品类时系统的类成对增加（concreteProduct与concreteFactory），增加系统的复杂度，额外的编译开销 适用场景 客户端不需知道类名，只需要知道工厂就可以 系统后续扩展趋势较大，用来保证系统解耦度]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2017%2F11%2F28%2FdesignPattern%2Fsimple_factory_pattern%2F</url>
    <content type="text"><![CDATA[简单工厂模式 使用工厂模式创建对象的好处通常我们在创建对象时最容易想到的就是new操作符，不过new操作符有许多局限：不够灵活，与业务类耦合度过大，也将初始化对象等无关业务细节暴露（我们只是要获取对象，不关心其他，初始化对象等细节操作何不交给其他类来完成？）。 一般可以采用工厂模式来解决这类问题。由一个第三方类（Factory类）来创建对象，将对象创建过程封装起来，降低系统耦合度。 概念简单工厂模式（Simple Factory Pattern）并不属于GoF23个经典设计模式，不过它是学习其他工厂模式的基础。概念也比较简单。 定义：定义一个工厂类，里面存在个static方法，根据不同参数返回不同实例，返回的实例通常具有共同父类。结构图如下： 实例下面来举个简单的例子吧。想必很多同学都被家里长辈唠叨过怎么还不找女朋友。那我们就拿这个事来举个简单工厂的例子吧。 首先编写Product与ConcreteProduct类： 1234567891011121314151617181920212223242526272829public abstract class Girl &#123; //女孩的品质 public void character() &#123; System.out.println(&quot;我是一个漂亮的，身材棒的女孩！&quot;); &#125; //女孩的名字 public abstract void name ();&#125;public class XiaoCao extends Girl &#123; @Override public void name() &#123; System.out.println(&quot;我的名字是小草！&quot;); &#125;&#125;public class XiaoHua extends Girl &#123; @Override public void name() &#123; System.out.println(&quot;我的名字是小花！&quot;); &#125;&#125;public class XiaoYe extends Girl &#123; @Override public void name() &#123; System.out.println(&quot;我的名字是小叶！&quot;); &#125;&#125; 可以看到，我们创建了一个抽象类，并用这个类实现了三个具体类。 假如你现在有三个女朋友（不是让你脚踏三只船，只是为了例子说明），Mother要看看她们。我们很容易就想到下面实现： 1234567891011public class Mother &#123; public static void main(String[] args) &#123; Girl girlFriend = new XiaoCao();//小草 girlFriend.character(); girlFriend.name(); &#125;&#125;运行结果：我是一个漂亮的，身材棒的女孩！我的名字是小草！ 看起来很棒，运行结果也没问题。不过Mother看完小草不是那么满意，又想看小花了。或者Father、Sister什么的七大姑八大姨都要来看。这可怎么办，只能修改Mother类了。难道每次换想法我都要改一次吗？有没有一种方法可以直接给他们想要的，需要什么就给什么。 我们可以建立一个Factory类，你想看哪个直接取就是了。 12345678910111213public class GirlFactory &#123; public static Girl getGrilFriend (String name) &#123; Girl girl = null; if (name.equals(&quot;小草&quot;)) &#123; girl = new XiaoCao(); &#125; else if (name.equals(&quot;小花&quot;)) &#123; girl = new XiaoHua(); &#125; else if (name.equals(&quot;小叶&quot;)) &#123; girl = new XiaoYe(); &#125; return girl; &#125;&#125; Mother类变为： 1234567891011public class Mother &#123; public static void main(String[] args) &#123; Girl girlFriend = GirlFactory.getGrilFriend(&quot;小花&quot;); girlFriend.character(); girlFriend.name(); &#125;&#125;运行结果：我是一个漂亮的，身材棒的女孩！我的名字是小花！ 将创建对象的职责交给第三方类(Factory)来执行,来达到解耦合的目的。什么七大姑八大姨想看也直接从Factory里取就是了。 不过缺点想必大家也可以看出，如果需要增加新的ConcreteProduct类时必须修改Factory类，这违背了开闭原则。当需要创建的对象很多时也势必会增加Factory类的复杂度，所以它适用于需要用Factory类创建少量对象的场合。 总结缺点 Factory类负责相关所有对象的创建，职责过重，复杂度高 添加新产品时必须修改Factory类，违背开闭原则 适用场景 需要创建的对象不多时，Factory类复杂度不会太高 客户端只需要知道传入的参数，对如何创建对象并不关心]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象的设计原则]]></title>
    <url>%2F2017%2F11%2F26%2FdesignPattern%2Fdesign_pattern_principle%2F</url>
    <content type="text"><![CDATA[面向对象的设计原则 在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。下面简单阐述下各个设计原则的概念。 单一职责原则（Single Responsibility Principle, SRP） 定义：一个类只负责一个功能领域中的相应职责 理解： 类的设计不能太臃肿，避免造成不可复用、维护不便等问题。比如WEB系统MVC分层设计就包含了单一职责原则思想，DAO层可以被复用，也便于维护。 开闭原则（Open-Closed Principle, OCP） 定义：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 理解：抽象化是开闭原则的关键，类的结构设计应具有抽象化的思想，当增加修改时不应大幅度改变原代码结构。java抽象类与接口的概念符合开闭原则，当修改类功能时直接扩展基类就可以。 里氏代换原则（Liskov Substitution Principle, LSP） 定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。 理解：里氏代换原则是开闭原则的具体实现手段之一。在传递参数、声明类型、定义变量时都可使用里氏代换原则，也就是用基类（抽象类、接口）来定义类型，待到运行时才确定具体子类类型。 依赖倒转原则(Dependency Inversion Principle, DIP) 定义：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 理解：实现依赖倒转原则时，针对抽象编程。将具体类的对象通过依赖注入具体注入到其他对象中。（感觉与里氏代换原则很像，分不清…这里理解为里氏代换原则是基础，依赖倒转原则为具体实现） 接口隔离原则（Interface Segregation Principle, ISP） 定义：使用多个专门的接口，而不使用单一的总接口。 理解：接口的粒度必须控制得当，太小会使系统中接口暴增，不利于维护。太大则灵活性较差，且违背单一职责原则。 合成复用原则（Composite Reuse Principle, CRP） 定义：尽量使用对象组合，而不是继承来达到复用的目的。 理解：继承的依赖性相对较强，修改时牵一发而动全身。若两个类之间的关系不是严格的类别关系，而是某个点的职责关系，优先考虑使用合成复用原则。 迪米特法则（Law of Demeter, LoD） 定义： 一个软件实体应当尽可能少地与其他实体发生相互作用。 理解：当前类不要与没有直接关系的类进行消息传递。如必要可以使用中间类（Mediator）来达到松耦合的目的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2017%2F11%2F15%2Flinux%2Flinux_command%2F</url>
    <content type="text"><![CDATA[linux常用命令 基本操作快捷键 登录shell ctrl+shift+f1-f6 退出shell到图形页面 ctrl+shift+f7 命令补全 tab 暂停正在运行的shell程序执行 ctrl+c 注销shell执行（=exit） ctrl+d 基本操作命令行 修改shell支持语言 查看语言编码格式 echo $LANG 修改语言格式为英文 LANG=en_US 切换用户 su 查看日期 date 查看日历 cal 计算器 bc 显示小数位数（默认整数）sclae=n 离开计算器 quit 命令行帮助文档 man+命令行 将数据同步写入硬盘（一般root写入）*sync 关机 shutdown -h 立即关机 -r 立即重启 -k 只显示消息 shutdown -h +10/20:15 ‘we are readying the linux after 10min/ in 20:15’ 在10分钟后（或于20:15）关机，并且在当前登录此机器的用户屏幕前显示信息 文件系统检查 fsck 文件管理命令行 展示所有文件 ls -al 展示特定文件夹下文件 ls -l /../.. 改变文件用户组 chgrp groupname dirname/filename 改变文件所有者 chown ownname [:groupname] dirname/filename 改变文件权限 chmod numberList|chatList dirname/filename rwz三种权限对应数字分别为4 2 1,如果将test.text的权限修改为 rwxrxrw，命令也就是 chmod 756 test.text 也可以使用u g o通过+ - =操作符来修改 创建文件 touch dirname/filename 文件目录操作 特殊符号： 当前目录： .上层目录： ..前一个工作目录： -当前账户主目录： ~account账户主目录： ~ account 相关命令： 切换目录：cd 显示当前目录：pwd 创建目录： mkdir 删除目录：rmdir 移动文件：mv 删除文件：rm 新建文件： touch 赋予文件隐藏属性 ： chattr 新增环境变量：PATH=”$PATH”:/dirname 查找执行文件（PATH下）：which 查找特定文件: whereis 查找本地文件：locate(可使用updatedb更新下数据文件再查找，比较耗时) 详细检索文件(磁盘检索): find 查看文件系统属性: dumpe2fs 查看当前使用的文件系统: df 查看文件系统详情: du 磁盘操作: fdisk (使用前需用df命令找到文件系统路径) 磁盘格式化: mkfs 挂载命令: mount 检查文件系统:fsck 文件压缩：gzip (.gz)、bzip2(.bz2) 打包压缩（z代表gzip,j代表bzip2）tar -zpcv -f /root/etc.tar.gz /etc 查看压缩文件 tar -ztv -f /root/etc.tar.gz 解压缩到指定文件夹 tar -zxv -f /root/etc.tar.gz -C /tmp bash相关命令 查看环境变量：env 或 set 取消环境变量 : unset 变量键盘读取 : read 声明变量类型 : declare或typeset 直接写入配置文件: source 或 . 特殊符号 以覆盖的方法将正确的数据输出：1&gt; 以累加的方法将正确的数据输出： 1&gt;&gt; 以覆盖的方法将错误的数据输出：2&gt; 以累加的方法将错误的数据输出：2&gt;&gt; 标准输入源 : &lt; 标准输入源结束标志 : &lt;&lt; 管道命令 分割字符 ： cut 匹配对应行：grep 排序：sort 去重 ：uniq 统计: wc 截取数据流重定向：tee 替换，删除字符串 : tr 过滤控制字符：col 多文件相关栏位联结：join 多文件相关栏位粘贴：paste tab转空格：expand -t 切割文件 ： split -b 一般命令参数代换为管道命令： xargs 常用处理工具：sed，printf, awk]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux VIM编辑器快捷键]]></title>
    <url>%2F2017%2F11%2F09%2Flinux%2Flinux_vim%2F</url>
    <content type="text"><![CDATA[linux VIM编辑器快捷键基本操作 i 一般模式进入编辑模式 esc 退出编辑模式到一般模式 :wq 一般模式下退出vim编辑器并保存更改 移动光标 h 或 ← 向左移动一个字符 j 或 ↓ 向下移动一个字符 k 或 ↑ 向上移动一个字符 l 或 → 向右移动一个字符 多次操作采用 数字+快捷键,例如向上移动10个字符可用 10+k 快捷键 ctrl+f 或 PageDown 向下移动一页 【常用】 ctrl+b 或 PageUp 向上移动一页 【常用】 ctrl+d 向下移动半页 ctrl+u 向上移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n[space] 光标向右移动n个距离 0 或 home 光标移动至行首 【常用】 $ 或 end 光标移动至行尾 【常用】 H 光标移动至当前屏幕区域首行 M 光标移动至当前屏幕区域中间行 L 光标移动至当前屏幕区域尾行 G 光标移动至当前文件的尾行 【常用】 nG 光标移动至当前文件的第n行 gg 光标移动至当前文件的第1行【常用】 查找与替换 /word 向下寻找名为word的字符串【常用】 ?word 向上寻找名为word的字符串 n 重复前一个查找操作 N 反向重复前一个查找操作 :n1,n2s/word1/word2/g n1行到n2行将word1替换word2【常用】 :1,$s/word1/word2/g第一行到最后一行将word1替换word2【常用】 :1,$s/word1/word2/gc第一行到最后一行将word1替换word2，并提示是否操作【常用】 删除与复制粘贴 x,X 向后（前）删除一个字符【常用】 nx 向后删除n个字符【常用】 nx 向后删除n个字符 dd 删除光标所在那一整行 ndd 删除光标所在下n整行 d1G 删除光标所在到第一行的所有数据 dG 删除从光标所在到最后一行的所有数据 d$ 删除从光标所在处到该行的最后一个字符 d0 删除从光标所在处到该行的最前面一个字符 yy 复制光标所在的那一行【常用】 nyy 复制光标所在的向下n行【常用】 y1G 复制光标所在行到第一行的所有数据 yG 复制光标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p,P 向下粘贴（向上粘贴）【常用】 J 将光标所在行与下一行的数据结合成同一行 u 复原前一个操作【常用】 ctrl+r 重做前一个操作【常用】 . 重复前一个操作【常用】 :!command 暂时离开 vi到命令行模式下执行 command 的显示结果 编辑模式进入插入模式（Insert mode）： i，I i为从目前光标所在处插入，I为在目前所在行的第一个非空格符处开始插入【常用】 a，A a 为从目前光标所在的下一个字符处开始插入，A 为从光标所在行的最后一个字符处开始插入【常用】 o，O o 为在目前光标所在的下一行处插入新的一行；O 为在目前光标所在处的上一行插入新的一行【常用】 进入替换模式（Replace mode）： r，R r 只会替换光标所在的那一个字符一次；R 会一直替换光标所在的文字，直到按下[Esc]键为止【常用】]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通用excel导出demo]]></title>
    <url>%2F2017%2F05%2F03%2FcodeExample%2Fexcel_export_byReflect%2F</url>
    <content type="text"><![CDATA[通用excel导出demo（利用反射）最近项目后台管理系统好多地方都要用到excel导出。考虑到一次次修改原代码太无聊，各方面拼拼凑凑写出个通用类，传几个参数设定下表头就ok了。对反射的概念和相关api了解又加深了点…代码记录如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import org.apache.poi.hssf.usermodel.*;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;public class PoiTool &#123; /** * * @param list 数据源list * @param beanClass list中Object的Class对象 * @param map 表头名与对应字段集合（需预定义，例&#123;&lt;用户名,username&gt;&lt;密码，password&gt;&#125;） * @param response 响应对象 * @throws IllegalAccessException * @throws InstantiationException * @throws InvocationTargetException */ public static void exportExcel(List list, Class beanClass, LinkedHashMap&lt;String, String&gt; map, HttpServletResponse response) throws IllegalAccessException, InstantiationException, InvocationTargetException &#123; int j = 0; String valueStr = &quot;&quot;; HSSFWorkbook wb = new HSSFWorkbook(); HSSFSheet sheet = wb.createSheet(&quot;sheet1&quot;); HSSFCellStyle style = wb.createCellStyle();//样式 style.setAlignment(HSSFCellStyle.ALIGN_CENTER); HSSFRow row = sheet.createRow(0);//第一行 for (Map.Entry&lt;String, String&gt; m : map.entrySet()) &#123;//导入excel表头 HSSFCell cell = row.createCell(j); cell.setCellValue(m.getKey()); cell.setCellStyle(style); sheet.autoSizeColumn(j); valueStr += m.getValue() + &quot;|&quot;;//filed字符串 j++; &#125; valueStr = valueStr.substring(0, valueStr.length() - 1); System.out.println(valueStr); String[] valueArray = valueStr.split(&quot;\\|&quot;);//filed数组 //通过反射获取对应beanClass中的字段 //并将其转为get方法置入集合中 Field field[] = beanClass.getDeclaredFields(); List&lt;Method&gt; methodlist = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; field.length; i++) &#123; String fieldName = field[i].getName(); StringBuffer methodName = new StringBuffer(&quot;get&quot;); methodName.append(fieldName.substring(0, 1).toUpperCase()); methodName.append(fieldName.substring(1)); Method getMethod = null; try &#123; getMethod = beanClass.getMethod(methodName.toString()); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; methodlist.add(getMethod); &#125; //遍历list，并插入数据 for (int i = 0; i &lt; list.size(); i++) &#123; row = sheet.createRow(i + 1);//创建行，从第二行开始 for (int k = 0; k &lt; valueArray.length; k++) &#123;//遍历column Method getMethod = getCurrentMethod(valueArray[k], methodlist);//获取colunm对应的get方法 if (getMethod.getReturnType().toString().indexOf(&quot;int&quot;) &gt;= 0) &#123; row.createCell(k).setCellValue((int) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; else if (getMethod.getReturnType().toString().indexOf(&quot;String&quot;) &gt;= 0) &#123; row.createCell(k).setCellValue((String) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; else if (getMethod.getReturnType().toString().indexOf(&quot;double&quot;) &gt;= 0) &#123; row.createCell(k).setCellValue((double) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; else if (getMethod.getReturnType().toString().indexOf(&quot;float&quot;) &gt;= 0) &#123; row.createCell(k).setCellValue((float) getMethod.invoke(list.get(i), new Object[]&#123;&#125;)); &#125; &#125; sheet.autoSizeColumn(i); &#125; response.reset(); response.setContentType(&quot;application/vnd.ms-excel;charset=gb2312&quot;); response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=excel.xls&quot;); try &#123; OutputStream outputStream = response.getOutputStream(); wb.write(outputStream); wb.close(); outputStream.flush(); outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //获取当前column的get方法 public static Method getCurrentMethod(String valueArray, List&lt;Method&gt; methodlist) &#123; if (valueArray != null &amp;&amp; methodlist.size() &gt; 0) &#123; for (int i = 0; i &lt; methodlist.size(); i++) &#123; if (methodName(methodlist.get(i).getName()).equals(valueArray)) &#123; return methodlist.get(i); &#125; &#125; &#125; return null; &#125; //处理methodName public static String methodName(String str) &#123; if (str != null) &#123; str = str.substring(3).substring(0, 1).toLowerCase() + str.substring(3).substring(1); return str; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众平台普通红包发放]]></title>
    <url>%2F2017%2F04%2F25%2Fwexin%2Fweixin_web_OrdinaryRedPacket%2F</url>
    <content type="text"><![CDATA[业务需求：在后台管理系统为微信用户发放红包，弄了好几天总算搞定了，需要注意的是获取签名部分，流程大体如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210//红包业务方法public int sendRedpack(HttpServletRequest request,UserAverage userAverage) throws Exception &#123; WechatInfo wechat = getWechatInfo(request); WechatInfo wechatInfo = wechatInfoService.queryWechatinfo(wechat.getAppid()); String sendName =wechatInfo.getWxname(); //微信证书路径 String certPath =this.getClass().getResource(&quot;/&quot;).getPath()+&quot;xxxxx/apiclient_cert.p12&quot;; certPath = URLDecoder.decode(certPath,&quot;UTF-8&quot;);//证书路径解码 logger.info(&quot;证书路径:&quot;+certPath); //商户id String wxappid = wechatInfo.getAppid(); // 微信支付分配的商户号 String partner = wechatInfo.getPartnerid(); //API密钥 String paternerKey =wechatInfo.getPartnerkey(); /** * 发送普通红包 */ boolean isSend = sendredpack(wechatInfo,request, &quot;100&quot;, &quot;1&quot;, &quot;恭喜您获得竞赛奖金！&quot;, &quot;竞赛答题活动&quot;, &quot;竞赛奖金&quot;, userAverage.getOpenid(), partner, wxappid, sendName, paternerKey, certPath); if(!isSend)&#123; return 0; &#125; return 1;&#125;// 主封装方法// * @param request 获取IP// * @param total_amount 付款现金(单位分)// * @param total_num 红包发放总人数// * @param wishing 红包祝福语// * @param act_name 活动名称// * @param remark 备注// * @param reOpenid 用户openid// * @param partner 商户号// * @param wxappid 公众账号appid// * @param sendName 商户名称// * @param paternerKey 商户签名key// * @param certPath 证书路径// * @return// */ public static boolean sendredpack(WechatInfo wechatInfo,HttpServletRequest request,String total_amount,String total_num,String wishing,String act_name,String remark,String reOpenid,String partner,String wxappid,String sendName,String paternerKey,String certPath) throws Exception&#123; // 商户订单号 String mchBillno = RedPackUtil.createBillNo(wechatInfo); String ip =&quot;xxx.xx.xxx.xx&quot;;//服务器IP Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(); // 随机字符串 params.put(&quot;nonce_str&quot;, RedPackUtil.createNonce_str()); // 商户订单号 params.put(&quot;mch_billno&quot;, mchBillno); // 商户号 params.put(&quot;mch_id&quot;, partner); // 公众账号ID params.put(&quot;wxappid&quot;, wxappid); // 商户名称 params.put(&quot;send_name&quot;, sendName); // 用户OPENID params.put(&quot;re_openid&quot;, reOpenid); // 付款现金(单位分) params.put(&quot;total_amount&quot;, total_amount); // 红包发放总人数 params.put(&quot;total_num&quot;, total_num); // 红包祝福语 params.put(&quot;wishing&quot;, wishing); // 终端IP params.put(&quot;client_ip&quot;, ip); // 活动名称 params.put(&quot;act_name&quot;, act_name); // 备注 params.put(&quot;remark&quot;, remark); //创建签名 String sign = RedPackUtil.redSignal(params, paternerKey); logger.info(&quot;md5签名：&quot;+sign); params.put(&quot;sign&quot;, sign); String xmlResult = RedPackUtil.sendRedPack(params, certPath, partner);//执行发送红包 logger.info(&quot;发送红包返回结果：&quot;+xmlResult.toString()); Map&lt;String, String&gt; result = XMLUtil.xml2Map(xmlResult); logger.info(&quot;红包参数：&quot;+result.toString()); //此字段是通信标识，非交易标识，交易是否成功需要查看result_code来判断 String return_code = result.get(&quot;return_code&quot;); //业务结果 String result_code = result.get(&quot;result_code&quot;); if (StringUtils.isNotBlank(return_code) &amp;&amp; &quot;SUCCESS&quot;.equals(return_code)) &#123; logger.info(&quot;通信成功return_code：&quot;+return_code); if (StringUtils.isNotBlank(result_code) &amp;&amp; &quot;SUCCESS&quot;.equals(result_code)) &#123; logger.info(&quot;发送成功result_code：&quot;+result_code); return true; &#125;else&#123; logger.info(&quot;发送失败result_code：&quot;+result_code); &#125; &#125;else&#123; logger.info(&quot;通信失败return_code：&quot;+return_code); &#125; return false; &#125; /** * 生成商户订单号 * @param mch_id 商户号 * @param userId 该用户的userID * @return */public static String createBillNo(WechatInfo wechatInfo)&#123; //组成： mch_id+yyyymmdd+10位一天内不能重复的数字 //10位一天内不能重复的数字实现方法如下: //因为每个用户绑定了userId,他们的userId不同,加上随机生成的(10-length(userId))可保证这10位数字不一样 Date dt=new Date(); SimpleDateFormat df = new SimpleDateFormat(&quot;yyyymmdd&quot;); String nowTime= df.format(dt); int length = 10 ; return wechatInfo.getPartnerid() + nowTime + getRandomNum(length);&#125;/** * 生成红包参数随机数nonce_str * @return */public static String createNonce_str()&#123; return System.currentTimeMillis()/1000+getRandomNum(5);&#125;/** * 生成特定位数的随机数字 * @param length * @return */public static String getRandomNum(int length) &#123; String val = &quot;&quot;; Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; val += String.valueOf(random.nextInt(10)); &#125; return val;&#125;/*** @Title: redSignal * @Description: 发送红包签名生成* @param @param params* @param @return 设定文件 * @return String 返回类型 * @throws*/public static String redSignal(Map&lt;String, String&gt; params,String paternerKey) &#123;SortedMap&lt;String, String&gt; packageParams = new TreeMap&lt;String, String&gt;();for (Map.Entry&lt;String, String&gt; m : params.entrySet()) &#123;packageParams.put(m.getKey(), m.getValue().toString());&#125;StringBuffer sb = new StringBuffer();Set&lt;?&gt; es = packageParams.entrySet();Iterator&lt;?&gt; it = es.iterator();while (it.hasNext()) &#123;Map.Entry entry = (Map.Entry) it.next();String k = (String) entry.getKey();String v = (String) entry.getValue();if (!StringUtils.isEmpty(v) &amp;&amp; !&quot;sign&quot;.equals(k) &amp;&amp; !&quot;key&quot;.equals(k)) &#123;sb.append(k + &quot;=&quot; + v + &quot;&amp;&quot;);&#125;&#125;sb.append(&quot;key=&quot; + paternerKey);System.out.println(&quot;未加密签名：&quot;+sb.toString());String sign = MD5Util.MD5Encode(sb.toString(),&quot;UTF-8&quot;).toUpperCase();return sign;&#125;private static String sendRedPackUrl = &quot;https://api.mch.weixin.qq.com/mmpaymkttransfers/sendredpack&quot;;/** * 发送红包 * @param params 请求参数 * @param certPath 证书文件目录 * @param partner 证书密码 * @return &#123;String&#125; * @throws Exception */public static String sendRedPack(Map&lt;String, String&gt; params, String certPath, String partner) throws Exception &#123; return doSend(sendRedPackUrl, XMLUtil.map2Xmlstring(params), certPath, partner);&#125;public static String doSend(String url, String data , String certPath , String partner) throws Exception &#123; KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;); FileInputStream instream = new FileInputStream(new File(certPath));//P12文件目录 try &#123; keyStore.load(instream, partner.toCharArray());//这里写密码..默认是你的MCHID &#125; finally &#123; instream.close(); &#125; SSLContext sslcontext = SSLContexts.custom() .loadKeyMaterial(keyStore, partner.toCharArray())//这里也是写密码的 .build(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] &#123; &quot;TLSv1&quot; &#125;, null, SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER); CloseableHttpClient httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build(); try &#123; HttpPost httpost = new HttpPost(url); // 设置响应头信息 httpost.addHeader(&quot;Connection&quot;, &quot;keep-alive&quot;); httpost.addHeader(&quot;Accept&quot;, &quot;*/*&quot;); httpost.addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;); httpost.addHeader(&quot;Host&quot;, &quot;api.mch.weixin.qq.com&quot;); httpost.addHeader(&quot;X-Requested-With&quot;, &quot;XMLHttpRequest&quot;); httpost.addHeader(&quot;Cache-Control&quot;, &quot;max-age=0&quot;); httpost.addHeader(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0) &quot;); httpost.setEntity(new StringEntity(data, &quot;UTF-8&quot;)); CloseableHttpResponse response = httpclient.execute(httpost); try &#123; HttpEntity entity = response.getEntity(); String jsonStr = toStringInfo(response.getEntity(),&quot;UTF-8&quot;); EntityUtils.consume(entity); return jsonStr; &#125; finally &#123; response.close(); &#125; &#125; finally &#123; httpclient.close(); &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序支付接口二次签名]]></title>
    <url>%2F2017%2F04%2F12%2Fwexin%2Fweixin_miniProgram_sign%2F</url>
    <content type="text"><![CDATA[今天小程序的支付接口遇到签名错误问题。折腾半天…原因是：小程序支付的签名需要进行2次！！！不是成功获取订单后微信服务器回调的xml中的那个sign。 接口返回下列参数供小程序调用1234paySign //签名 prePay.getMiniPackage(prepayid));timeStamp //时间戳 prePay.getTimeStamp());nonceStr//随机签名 prePay.getNonce_str()); package//预支付订单，格式为prepay_id=*; 其中主要参数 paySign，是二次签名。具体签名参数 是采用 调用微信接口获取到预支付订单prepayid后服务器返回的参数（包括小程序需要调用的nonceStr,prepay_id）， 主要用下列参数生成paySign，语法如下：1appId=【appid】&amp;nonceStr=【随机字符串】&amp;package=prepay_id=【返回的prepay_id】&amp;signType=MD5&amp;timeStamp=【时间戳】&amp;key=【支付秘钥】 二次签名代码如下：12345678910111213141516171819public String getMiniPackage(String prepay_id) &#123; TreeMap&lt;String, String&gt; treeMap = new TreeMap&lt;String, String&gt;(); String timeStamp=OrderUtil.GetTimestamp(); setTimeStamp(timeStamp); treeMap.put(&quot;appId&quot;, this.appid); treeMap.put(&quot;nonceStr&quot;, getNonce_str()); treeMap.put(&quot;package&quot;, &quot;prepay_id=&quot;+prepay_id); treeMap.put(&quot;signType&quot;, &quot;MD5&quot;); treeMap.put(&quot;timeStamp&quot;,timeStamp); StringBuilder sb = new StringBuilder(); for (String key : treeMap.keySet()) &#123; sb.append(key).append(&quot;=&quot;).append(treeMap.get(key)).append(&quot;&amp;&quot;); &#125; sb.append(&quot;key=&quot; + partnerKey); System.out.println(&quot;小程序二次签名：&quot;+sb.toString()); sign = MD5Util.MD5Encode(sb.toString(), &quot;utf-8&quot;).toUpperCase(); return sign;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>weixin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础概念与语法]]></title>
    <url>%2F2016%2F05%2F23%2Fdatabase%2Fmysql_base%2F</url>
    <content type="text"><![CDATA[由于没有系统学过mysql，之前自己看的相关ppt资料也是囫囵吞枣式的，对视图、游标、事物什么的理解都不是很深刻。特意找了本基础的书（《mysql必知必会》）看了下。 常用命令关键词 登录账户：mysql -u username显示库的信息：show databases操作库之前选择对应的库：use database_name显示库中的表： show tables显示表的列： show columns from table_name 或 describe table_name正则表达式查找： REGEXP （用法同LIKE，只不过关键词右边跟的是正则串） mysql函数 字符串 字符串连接： concat(str…)串左边字符： left(str，len)串右边字符： right(str，len)串长度：length(str)字串位置 ： locate(substr，str)将串转小写：lower(str)将串转大写：upper(str)去全部空格：trim(str)去左边空格：ltrim(str)去右边空格：rtrim(str)返回子串：substirng(str FROM pos FOR len)soundex发音值：soundex(str) 日期 增加时间：Date_add(date，interval expr type)当前日期+时间：now()当前日期：curdate()当前时间：curtime()返回日期部分：Date(expr)返回时间部分：Time(expr)返回年份部分：year(expr)返回月份部分：month(expr)返回天数部分：day(expr)返回分钟部分：month(expr)返回秒数部分：second(expr)返回日期之差(result_type：day)：dateDiff(expr1，expr2)时间格式化：date_format(date,format)返回星期几：dayOfWeek(date) [1=星期日，2=星期一…7=星期六] 全文本查找 需要为被搜索列建立FULLTEXT索引，并且引擎为MYISAM; 建表语句例如：12345678CREATE TABLE test( id int NOT NULL AUTO_INCREMENT, msg text NULL, PRIMARY KEY (id), FULLTEXT(msg))ENGINE=MYISAM; 文本查找语句则为：1select msg from test where Match(msg) against(&quot;xiaoqiang&quot;); 视图 主要用来简化复杂查询语句，创建可重用的 “sql查询接口”，至于更新操作（包括插入，删除）则取决于视图建立条件，如果采用聚合函数、group by等就不允许更新。（更新视图实质上是对原表进行更新，不确定具体字段 自然不会允许更新） 创建视图：1CREATE VIEW `exam_view` AS select * from `exam` where appid = &apos;xxxxxxx&apos;; 存储过程 实质上是sql中的函数，主要用于处理复杂的sql业务（高效，安全）。例如用户商品下单时对库存商品进行一系列处理，检查商品，预定商品，更新库存数目等等 一系列流程就可采用存储过程实现。 创建过程中IN代表函数接收参数，OUT是返回结果，INOUT则复合了IN、OUT的特性。 显示存储过程信息： 12SHOW CREATE PROCEDURE processName;SHOW PROCEDURE STATUS [LIKE processName]; 创建存储过程: 1234CREATE PROCEDURE queryEnameByEid(IN eid_Para INT,OUT ename_result VARCHAR(100)) BEGIN SELECT ename FROM exam WHERE eid=eid_Para INTO ename_result;END; 执行存储过程： 1CALL processName(30,@ename_result); 调用函数结果： 1SELECT @ename_result; 游标 实质上是存储了数据序列的结果集，在mysql中只能用于存储过程中 1234567891011121314151617181920212223242526BEGIN -- 声明局部变量 DECLARE flag INT DEFAULT 0; DECLARE tmp_value VARCHAR(50); -- 声明游标 DECLARE my_cursor CURSOR FOR (SELECT ename FROM exam); -- 建表 CREATE TABLE IF NOT EXISTS test_cursor(id int AUTO_INCREMENT,ename VARCHAR(50),PRIMARY KEY(id)); -- 开启游标 OPEN my_cursor; -- 循环开始 REPEAT -- 将游标获取的值放局部变量里 FETCH my_cursor INTO tmp_value; -- 更改flag值 SET flag=flag+1; -- 插入语句 INSERT INTO test_cursor(ename) VALUES(tmp_value); -- 游标到10时结束循环 UNTIL flag=10 END REPEAT; -- 打印表数据 SELECT * FROM test_cursor; -- 关闭游标 CLOSE my_cursor; END 触发器 将事件与sql执行状况绑定,可使用NEW、OLD虚拟表访问具体操作的字段值 12CREATE TRIGGER delete_question_msg AFTER DELETE ON questionFOR EACH ROW SELECT &apos;delete question finished!&apos; INTO @msg; 12DELETE FROM question WHERE qid=528;SELECT @msg;]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基础符号概念]]></title>
    <url>%2F2016%2F05%2F17%2Fregx%2Fregx_base%2F</url>
    <content type="text"><![CDATA[在项目中解析文件部分使用java Pattern与Matcher类，自然少不了正则啦，在此将正则基础符号概念部分总结一下，比较精简… 句点符号. 任意单个字符 例：a.b 匹配三位长度字符串，中间任意字符；如a b，a1b，a-b等 方括号 圆括号[] 单字符长度范围， () 分组（不限长度） 例：a[123]b 匹配三位长度字符串，中间指定字符；如a1b,a2b,a3b，()用法同理 或符号| 或运算 例：(a|b|cc) 匹配a或b或cc，此处不可使用 [] 星号* 匹配左边字符0次或多次 例：a*[b] 匹配最后一位字符是b,前面字符全为a的字串或单个b字符，如ab，aaab，b 加号+ 匹配左边字符1次或多次 例: a+[b] 匹配第二位是b字符，b字符前面一个或多个a字符的字符串，如aab，ab,aaab 问号\? 匹配左边字符0次或一次（有或无此字符-&gt;有此字符也满足条件） 例：a?[ab] 匹配左边有a字符或无a字符，第二位为a或b的字符串，如a，ab，b 花括号{n} | {m-n} 匹配左边字符恰好n次 或 m-n 次（连续性） 例：a{3}b只匹配字符串aaab 否符号^ 非运算 例：[^a]b匹配第一个字符不是a，第二个字符是b的字符串 常用正则表达式符号\s 等价于 [\t\n\r\f] 即tab制表符、换行符、回车符、换页符，其一，也就是空白字符 \d等价于 [0-9] 也就是数字字符 \w等价于 [A-Z0-9] 也就是字符，字母字符无论大小写都匹配哦 \S \D \W 即上面三种符号定义的“非”逻辑]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>regx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决url传中文参数乱码]]></title>
    <url>%2F2016%2F03%2F23%2FfixBug%2FURL_ChineseParameter_MessyCode%2F</url>
    <content type="text"><![CDATA[解决url传中文参数乱码首先在前台js内将相应的中文参数（qsInfo）编码两次，相应代码如下。可用encodeURIComponent直接对中文参数进行编码，直接使用encodeURIComponent对url进行编码会使 / 字符转为16进制字符，这时你会发现页面没有定向到url的地址…1234var url=encodeURI(encodeURI(&apos;$&#123;ctx&#125;/backstage/getPraxisQuestionList?qsInfo=&apos;+qsInfo));or...var url=&apos;$&#123;ctx&#125;/backstage?qsInfo=&apos;+encodeURIComponent(encodeURIComponent(qsInfo));//var url=encodeURIComponent(encodeURIComponent(&apos;$&#123;ctx&#125;/backstage?qsInfo=&apos;+qsInfo));//url不跳转，/被编码了... 接着在java后台对相应字符进行解码就ok啦，代码如下 1String qsInfo = URLDecoder.decode(question.getQsInfo(),&quot;UTF-8&quot;);//字符解码,此处我的参数是直接封装在bean里的。 具体流程就是：前台编码2次，后台解码1次…]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
</search>
